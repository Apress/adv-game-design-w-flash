package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import flash.geom.Matrix;  import flash.utils.getTimer;  import com.friendsofed.utils.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class LotsOfMovieClips extends Sprite	{	  //Change this variable to determnine the number	  //of times the tiles sheet should be copied to the stage	  private var _timesToRepeat:uint = 10;	   	  //Create a blank BitmapData object as the canvas for this bitmap    private var _stageBitmapData:BitmapData       = new BitmapData(550, 400, true, 0);    private var _stageBitmap:Bitmap = new Bitmap(_stageBitmapData);        //The size of each tile square in the tileMap image    private var _tileSize:uint = 32;    private var _gridSize:uint = 4;        //Speed limit    private var _speedLimit:int = 3;        //Status box  	private var _statusBox:StatusBox = new StatusBox;  	  	//Create a performance profiler	  private var _performance:PerformanceProfiler 	    = new PerformanceProfiler();  	  	//Variables required to display the tile sheet bitmap		private var _tileBitmap:Bitmap;		private var _tileSheetImage:DisplayObject;		private var _tileBitmapData:BitmapData;	  	  //An array to store the tiles	  private var _tiles:Array = new Array();	  		//Embed the image of the cave    [Embed(source="../assets/images/charactersTileSheet.png")]    private var TileSheet:Class;				public function LotsOfMovieClips():void		{ 			//Create a new instance of the TileMap class			_tileSheetImage = new TileSheet();						//Create a BitmapData object to store the image			_tileBitmapData 			  = new BitmapData			  (			    _tileSheetImage.width, _tileSheetImage.height, true, 0			  );			_tileBitmapData.draw(_tileSheetImage);					  //Add the stage bitmap		  //this displays the contents of the _stageBitmapData		  //It will be updated automatically when		  //the _stageBitmapData is changed			addChild(_stageBitmap);						initializeTiles();						//Add the status box			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function initializeTiles():void		{		  for(var i:int = 0; i < _timesToRepeat; i++)      {		    //Slice the tile sheet into small squares called "tiles"		    for(var column:int = 0; column < _gridSize; column++)        {          for(var row:int = 0; row < _gridSize; row++)          {            //Create a tile			      var tileBitmapData:BitmapData 			        = new BitmapData(_tileSize, _tileSize, true, 0);			    			      //Create a rectangle object that's 			      //also the same size as the tile. 			      //This is the viewfinder that finds 			      //the right spot on the bitmap to copy.					  var sourceRectangle:Rectangle 					    = new Rectangle					    (					      column * _tileSize, 					      row * _tileSize, 					      _tileSize, 					      _tileSize					    );										  //A point object, which is needed to 					  //define the upper left corner of the bitmap					  //Leave this at 0,0 unless you need to offset it.            var point:Point = new Point(0, 0);                      //Copy the pixels from the original             //image's BitmapData into the new tileBitmapData            //The rectangle and point             //objects specify which part to copy            tileBitmapData.copyPixels              (_tileBitmapData, sourceRectangle, point);                      //Create a new Bitmap based on the tileBitmapData            //and add it to the stage            var tile:Bitmap = new Bitmap(tileBitmapData);                      //Create a particle MovieClip            var character:MovieClip = new MovieClip();            addChild(character);                        //Wrap the tile Bitmap in the particle MovieClip            //This allows it to be easily faded and rotated		        character.addChild(tile);                        //Position in the correct place on the stage            character.x = column * _tileSize;            character.y = row * _tileSize;		  		        //Give the tile a random velocity		        character.vx 		          = (Math.random() * _speedLimit) - _speedLimit / 2;		        character.vy 		          = (Math.random() * _speedLimit) - _speedLimit / 2;		  		        //Push the tile into the tiles array		        _tiles.push(character);          }        }      }		}		private function enterFrameHandler(event:Event):void		{ 		  //Loop through all the tiles.		  //Move the tiles by working out their new positions based		  //on the velocity's and positions of the tileModels		  for(var i:int = 0; i < _tiles.length; i++)      {        //1. Update the Models        //Update the position and velocity of the tileModels        _tiles[i].x += _tiles[i].vx;			  _tiles[i].y += _tiles[i].vy;			    			  //Check stage boundaries			  //Check left and right			  if(_tiles[i].x + _tileSize > stage.stageWidth			  || _tiles[i].x < 0)			  {			    _tiles[i].vx = -_tiles[i].vx;			  }			  //check top and bottom			  if(_tiles[i].y + _tileSize > stage.stageHeight			  || _tiles[i].y < 0)			  {			    _tiles[i].vy = -_tiles[i].vy;			  }      }      //Update status box			_statusBox.text = "LOTS OF MOVIECLIPS:"; 			_statusBox.text 			  += "\n" + "MOVIECLIPS ON STAGE: " + _tiles.length; 			_statusBox.text += "\n" + "FPS: " + _performance.fps;  			_statusBox.text 			  += "\n" + "MEMORY: " + _performance.memory + " MB";  		}	}}