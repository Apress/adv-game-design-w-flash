package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import com.friendsofed.utils.*;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class BitBlockTransfer extends Sprite	{	  //Create a blank BitmapData object as the canvas for this bitmap    private var _stageBitmapData:BitmapData       = new BitmapData(550, 400, true, 0);    private var _stageBitmap:Bitmap       = new Bitmap(_stageBitmapData);        //The size of each tile square in the tile sheet    private var _tileSize:uint = 32;    private var _gridSize:uint = 4;        //Speed limit    private var _speedLimit:int = 3;  	  	//Variables required to display the tile sheet bitmap		private var _tileBitmap:Bitmap;		private var _tileSheetImage:DisplayObject;		private var _tileBitmapData:BitmapData;	  	  //An array to store the tiles	  private var _tiles:Array = new Array();	  	  //Status box  	private var _statusBox:StatusBox = new StatusBox;	  		//Embed the image of the tile sheet    [Embed(source="../assets/images/tileSheet.png")]    private var TileSheet:Class;				public function BitBlockTransfer():void		{ 			//Create a new instance of the TileSheet class			_tileSheetImage = new TileSheet();						//Create a BitmapData object to store the image			_tileBitmapData 			  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 0			  );			_tileBitmapData.draw(_tileSheetImage);					  //Add the stage bitmap		  //This bitmap will be updated automatically when		  //the _stageBitmapData is changed			addChild(_stageBitmap);						//Add the status box			addChild(_statusBox);						//Initialize the tiles			initializeTiles();						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function initializeTiles():void		{		  //Loop through each tile in the tile sheet		  for(var column:int = 0; column < _gridSize; column++)      {        for(var row:int = 0; row < _gridSize; row++)        {          //Create a tile object to store the tile's original          //position and give it an initial velocity          //This become's the tile's "Model"          var tileModel:Object = new Object();                    //Record the tile's position on the _tileSheet image          //so that the correct section of the _tileSheet can be found          //when the tile is copied onto the stage bitmap          tileModel.tileSheet_X = column * _tileSize;          tileModel.tileSheet_Y = row * _tileSize;                      //Set the tile's start x and y position on the stage          tileModel.x = tileModel.tileSheet_X;          tileModel.y = tileModel.tileSheet_Y;		  		      //Give the tile a random velocity		      tileModel.vx 		        = (Math.random() * _speedLimit) - _speedLimit / 2;		      tileModel.vy 		        = (Math.random() * _speedLimit) - _speedLimit / 2;		  		      //Push the tile into the tiles array		      _tiles.push(tileModel);        }      }		}				private function enterFrameHandler(event:Event):void		{ 		  //Clear the bitmap from the previous frame so that it's		  //blank when you add the new particle positions		  _stageBitmapData.fillRect(_stageBitmapData.rect, 0);		  		  //Move the tiles by working out their new positions based		  //on the velocity's and positions of the tileModels		  for(var j:int = 0; j < _tiles.length; j++)      {        //1. Update the Models        //Update the position and velocity of the tileModels        _tiles[j].x += _tiles[j].vx;			  _tiles[j].y += _tiles[j].vy;			    			  //Check stage boundaries			  //Check left and right			  if(_tiles[j].x + _tileSize > _stageBitmapData.width			  || _tiles[j].x < 0)			  {			    _tiles[j].vx = -_tiles[j].vx;			  }			  //check top and bottom			  if(_tiles[j].y + _tileSize > _stageBitmapData.height			  || _tiles[j].y < 0)			  {			    _tiles[j].vy = -_tiles[j].vy;			  }			    			  //2. Create the Views: display the tiles on the stage bitmap			    			  //Find the tileModel's corresponding tile in the tileMap's			  //BitmapData and plot it to a new position 			  //in the containing stage bitmap			  //This is the tile's "View"			            //Create a Rectangle object that's aligned         //to the correct spot on the        //tile sheet. It's top left position         //matches the top left position on the        //tile sheet based on the tile we need.         //These positions are stored in the        //tile Model objects.			  var sourceRectangle:Rectangle 			    = new Rectangle			    (			      _tiles[j].tileSheet_X, 				    _tiles[j].tileSheet_Y, 				    _tileSize, 				    _tileSize				  );									//Create a Point object that defines the new position of the				//tile on on the stage bitmap.				//This is tile's stage position        var destinationPoint:Point           = new Point(_tiles[j].x, _tiles[j].y);                  //Copy the tile from the original tile         //sheet and project it onto the        //correct new place on the stage bitmap        //If your original tile bitmap uses any         //areas of transparency, make sure to add the last         //"true" parameter. This is "mergeAlpha".         //It lets transparent areas show through        _stageBitmapData.copyPixels          (            _tileBitmapData,             sourceRectangle,             destinationPoint,             null,             null,             true          );      }		        //Update status box			_statusBox.text = "BIT BLOCK TRANSFER:"; 			_statusBox.text += "\n" + "TILES ON STAGE: " + _tiles.length;  		}	}}