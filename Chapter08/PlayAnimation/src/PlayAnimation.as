package{	import flash.events.*;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import flash.geom.Matrix;  import flash.utils.Timer;  import com.friendsofed.utils.*;  import com.friendsofed.vector.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="640", height="512",   backgroundColor="#FFFFFF", frameRate="60")]  	public class PlayAnimation extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 10;	  private const MAP_ROWS:uint = 8;	  	  //tile ID numbers in tile sheet	  private const PLATFORM:uint = 00;	  private const SKY:uint = 10;	  private const CAT:uint = 20;	  private const SOFT_PLATFORM:uint = 01;	  private const ELEVATOR:uint = 22;	  private const STAR:uint = 02;	  private const HEDGEHOG:uint = 21;	  	  private var _platformMap:Array	    = [	        [10,10,10,10,10,10,10,10,10,10],	        [10,10,10,10,10,00,00,01,10,10],	        [10,10,10,10,10,10,10,10,10,10],	        [10,10,10,10,10,10,10,10,10,10],	        [10,10,10,00,00,00,00,00,10,10],	        [10,10,10,10,10,10,10,10,10,10],	        [10,10,00,10,10,10,10,10,10,10],	        [00,00,00,00,00,00,00,00,00,00]	      ];    	      	  private var _gameObjectMap:Array      = [          [-1,-1,-1,-1,-1,02,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,21,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,22,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,20,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        ];          	  //Create blank BitmapData objects as the canvas for this game    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);    private var _foregroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _foregroundBitmap:Bitmap       = new Bitmap(_foregroundBitmapData);  	  	//Tile sheet  	//Variables required to display the tile sheet bitmap		[Embed(source="../../images/tileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Create a TileModel to represent the cat    private var _catModel:TileModel;    private var _UIPlatformController:UIPlatformController;    private var _UIPlatformView:UIPlatformView;				//Create TileModels for the game objects		private var _elevatorModel:TileModel;		private var _starModel:TileModel;		private var _hedgehogModel:TileModel;				//Variables to track the position of the explosion		private var _explosion_X:Number = 0		private var _explosion_Y:Number = 0;				//Animation timer		private var _animationTimer:Timer;  				//Create a collision Controller to handle the collision		//between the player and the platforms		//You'll find the TileCollisionController in the		//com.friendsofed.utils package				private var _collisionController:TileCollisionController		 = new TileCollisionController();          private var _currentTile:uint = 0;    private var _mapRow:uint = 0;    private var _mapColumn:uint = 0;        //Status box  	private var _statusBox:StatusBox = new StatusBox;				public function PlayAnimation():void		{  		  //Draw the BitmapData objects			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the stage bitmap		  //this displays the contents of the _backgroundBitmapData		  //It will be updated automatically when		  //the _backgroundBitmapData is changed			addChild(_backgroundBitmap);			addChild(_foregroundBitmap);						//Add the status box			addChild(_statusBox);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_platformMap);			buildMap(_gameObjectMap);				addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}		private function enterFrameHandler(event:Event):void		{ 		  //Update the models		  _catModel.update();		  _elevatorModel.update();  	    	  //Set the elevator's limits and reverse  	  //its velocity if it crosses them  	  if(_elevatorModel.top == 0	    || _elevatorModel.bottom == 5)  	  {  	    _elevatorModel.vy = -_elevatorModel.vy;  	  }  	  		  //Stop the cat at the stage boundaries		  StageBoundaries.stopBitmap(_catModel, stage); 		  		  if(_catModel.yPos + _catModel.height >= stage.stageHeight)		  {		    _catModel.jumping = false;		  }		  		  //Clear the stage bitmap from the previous frame so that it's		  //blank when you add the new tile positions		  _foregroundBitmapData.fillRect(_foregroundBitmapData.rect, 0);		  		  //Enemy Movement  	  if(_hedgehogModel != null)		  {		    //1. Update the model		    _hedgehogModel.update();		    		    //2. Check platform boundaries  	    if    	    (    	      _platformMap      	      [_hedgehogModel.centerY + 1]      	      [_hedgehogModel.left]               == SKY            ||             _platformMap              [_hedgehogModel.centerY + 1]              [_hedgehogModel.right]               == SKY           )        {          _hedgehogModel.vx = -_hedgehogModel.vx;        }                //3. Collision check.        //Set the _hedgehogModel to "null" if the        //enemyCollision method returns "true"        if          (            _collisionController.enemyCollision		          (_catModel, _hedgehogModel)		      )		    {		      //Capture the hedgehog's position		      _explosion_X = _hedgehogModel.xPos;		      _explosion_Y = _hedgehogModel.yPos;		      		      //Start the timer		      _animationTimer = new Timer(200); 		      _animationTimer.start();		      		      //Send the explosion's x and y values to the		      //playExplosion method		      playExplosion(_explosion_X, _explosion_Y);		      		      //Null the hedgehog		      _hedgehogModel = null;		    }		    		    //4. Blit the hedgehog if enemyCollision returns "false"		    else		    {  		      drawGameObject(_hedgehogModel, _foregroundBitmapData);         }      }     		  if(_animationTimer		  && _animationTimer.running)		  {		    playExplosion(_explosion_X, _explosion_Y);		  }		  		  		  //Check for collision with the star		  //If the star exists...	    if(_starModel != null)	    {	      //Blit the star on the stage	      drawGameObject(_starModel, _foregroundBitmapData);	      	      //Check for a collision with the cat	      var collisionIsHappening:Boolean	        = _collisionController.starCollision  		       (  		         _catModel, _starModel,   		         _gameObjectMap, MAX_TILE_SIZE, STAR  		       );  		    		  //Set the _starModel to null if a collision is happening.  		  //This will prevent it from being displayed  		  //in the next frame, which makes it "invisible"     	      if(collisionIsHappening)  		  {  		    _starModel = null;  	    }	    }		  		  //Check for collisions with the platforms		  _collisionController.platformCollision		    (_catModel, _platformMap, MAX_TILE_SIZE, PLATFORM);		  		  //Check for collisions with the soft platforms		  _collisionController.softPlatformCollision		    (_catModel, _platformMap, MAX_TILE_SIZE, SOFT_PLATFORM);  		    		  //Check for collisions with the elevator		  _collisionController.elevatorCollision		    (_catModel, _elevatorModel);      		  //Star		  if(_starModel != null)	    {	      drawGameObject(_starModel, _foregroundBitmapData);	      if		      (  		      _collisionController.starCollision  		       (  		         _catModel, _starModel,   		         _gameObjectMap, MAX_TILE_SIZE, STAR  		       )  		    )  		  {  		    _starModel = null;  	    }	    }	    	    //Blit the moving objects on the foreground bitmap		  drawGameObject(_elevatorModel, _foregroundBitmapData);		  drawGameObject(_catModel, _foregroundBitmapData);		  		  //Update status box			_statusBox.text = "ANIMATION:"; 			_statusBox.text 			  += "\n" + "CAT JUMPING: " + _catModel.jumping;  			_statusBox.text 			  += "\n" + "CURRENT TILE: " 			  + _platformMap[_catModel.mapRow][_catModel.mapColumn]			  + ": " 			  + _catModel.mapRow 			  + _catModel.mapColumn;   		}				private function playExplosion(x:Number, y:Number):void	  {	    //The number of frames in the animation	    var animationFrames:uint = 2;	    	    //Animate while the _animationTimer's currentCount	    //is less than the number of frames	    if(_animationTimer.currentCount < animationFrames)      {        //Find the frames on the third row of the tile sheet	      var sourceRectangle:Rectangle = new Rectangle    			(    			  _animationTimer.currentCount * MAX_TILE_SIZE,     			  3 * MAX_TILE_SIZE,    			  MAX_TILE_SIZE, MAX_TILE_SIZE    			);								//The point on the stage where the animation should				//be displayed. This will be the same as the				//hedgehog's original position	    	  var destinationPoint:Point = new Point(x, y);              _foregroundBitmapData.copyPixels          (            _tileSheetBitmapData,             sourceRectangle,             destinationPoint,            null, null, true          );      }            //If the maximum number of animation frames      //has been reached, stop the _animationTimer      //and set the _explosion variable to false        else      {        //Stop and reset the timer        _animationTimer.stop();      }  	  } 		//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {      for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)      {        for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)        {          var currentTile:int = map[mapRow][mapColumn];                  if(currentTile > -1)          {            //Find the tile's column and row position            //on the tile sheet            var tileSheetColumn:uint               = uint(currentTile / 10);            var tileSheetRow:uint               = uint(currentTile % 10);                        switch(currentTile)              {                case CAT:                  _catModel        	          = new TileModel        	          (        	            MAX_TILE_SIZE,        	            tileSheetColumn, tileSheetRow,         	            mapRow, mapColumn,         	            48, 42        	          );   	                  	        //Add some gravity          	        _catModel.gravity_Vy = 0.98;  	                	        //Add the UIView and UIController          	        _UIPlatformController        	          = new UIPlatformController(_catModel);      	          _UIPlatformView      		          = new UIPlatformView      		          (_catModel, _UIPlatformController, stage);  		                  	        drawGameObject(_catModel, _foregroundBitmapData);        	        break;                          case PLATFORM:                  var platform:TileModel                   = new TileModel                  (                    MAX_TILE_SIZE,      	            tileSheetColumn, tileSheetRow,       	            mapRow, mapColumn,       	            MAX_TILE_SIZE, MAX_TILE_SIZE                  );      	          drawGameObject(platform, _backgroundBitmapData);                  break;                            case SKY:                  var sky:TileModel                     = new TileModel                    (                      MAX_TILE_SIZE,      	              tileSheetColumn, tileSheetRow,         	            mapRow, mapColumn,         	            MAX_TILE_SIZE, MAX_TILE_SIZE                    );      	          drawGameObject(sky, _backgroundBitmapData);                  break;                              case SOFT_PLATFORM:                 var softPlatform:TileModel                   = new TileModel                  (                    MAX_TILE_SIZE,                    tileSheetColumn, tileSheetRow,       	            mapRow, mapColumn,       	            MAX_TILE_SIZE, MAX_TILE_SIZE                  );      	        drawGameObject(softPlatform, _backgroundBitmapData);                break;                                case ELEVATOR:                 _elevatorModel                     = new TileModel                    (                      MAX_TILE_SIZE,                      tileSheetColumn, tileSheetRow,         	            mapRow, mapColumn,         	            64, 32                    );                  _elevatorModel.friction = 1;                    _elevatorModel.vy = -2;          	        drawGameObject        	          (_elevatorModel, _foregroundBitmapData);                break;                                  case STAR:                   _starModel                   = new TileModel                   (                     MAX_TILE_SIZE,                     tileSheetColumn, tileSheetRow,       	             mapRow, mapColumn,       	             48, 48                   );                 _starModel.setX = (mapColumn *  MAX_TILE_SIZE) + 8;                 _starModel.setY = (mapRow *  MAX_TILE_SIZE) + 8;                   drawGameObject(_starModel, _foregroundBitmapData);                 break;                                   case HEDGEHOG:                  _hedgehogModel                    = new TileModel                    (                      MAX_TILE_SIZE,                      tileSheetColumn, tileSheetRow,       	              mapRow, mapColumn,       	              48, 44                     );                  _hedgehogModel.setY                     = (mapRow *  MAX_TILE_SIZE) + 20;                    _hedgehogModel.friction = 1;                   _hedgehogModel.vx = -2;                   drawGameObject                    (_hedgehogModel, _foregroundBitmapData);                  break;               }          }        }      }    }				private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   			  tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point = new Point      (        tileModel.xPos,         tileModel.yPos      );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}