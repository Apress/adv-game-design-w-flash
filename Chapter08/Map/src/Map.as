package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import com.friendsofed.utils.*;  import com.friendsofed.vector.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="640", height="512",   backgroundColor="#FFFFFF", frameRate="60")]  	public class Map extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 10;	  private const MAP_ROWS:uint = 8;	  	  //The PLATFORM and SKY constants define	  //the position of tile images in the tile sheet	  private const PLATFORM:uint = 00;	  private const SKY:uint = 10;	 	  private var _platformMap:Array	    = [	        [10,10,10,10,10,10,10,10,10,10],	        [00,00,10,10,10,10,10,10,10,10],	        [10,10,10,10,10,10,00,00,00,10],	        [10,10,10,00,00,10,10,10,10,10],	        [10,10,10,10,10,10,10,10,10,10],	        [10,10,00,00,00,00,00,10,10,10],	        [10,10,10,10,10,10,10,10,10,10],	        [00,00,00,00,00,00,00,00,00,00]	      ]   	  	  //Alternative code using the Vector (typed array) class	  /*   	  private var _platformMap:Vector.<Vector.<int>> 		  = Vector.<Vector.<int>>		  (		    [	        Vector.<int>([10,10,10,10,10,10,10,10,10,10]),	        Vector.<int>([00,00,10,10,10,10,10,10,10,10]),	        Vector.<int>([10,10,10,10,10,10,00,00,00,10]),	        Vector.<int>([10,10,10,00,00,10,10,10,10,10]),	        Vector.<int>([10,10,10,10,10,10,10,10,10,10]),	        Vector.<int>([10,10,00,00,00,00,00,10,10,10]),	        Vector.<int>([10,10,10,10,10,10,10,10,10,10]),	        Vector.<int>([00,00,00,00,00,00,00,00,00,00])        ]      );    */    	  //Create a blank BitmapData object as the canvas for this bitmap    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);  	  	//Tile sheet  	//Variables required to display the tile sheet bitmap		[Embed(source="../../images/tileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Status box  	private var _statusBox:StatusBox = new StatusBox;				public function Map():void		{ 		  //Draw the tile sheet			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the stage bitmap.		  //This displays the contents of the _backgroundBitmapData.		  //It will be updated automatically when		  //the _backgroundBitmapData is changed			addChild(_backgroundBitmap);						//Run the buildMap method to convert the			//map's array data into a visual display			buildMap(_platformMap);						//Add the status box			addChild(_statusBox);						//Update status box			_statusBox.text = "MAP:"; 			_statusBox.text += "\n" + "TILE SIZE: " + MAX_TILE_SIZE; 			_statusBox.text += "\n" + "MAP ROWS: " + MAP_ROWS;  			_statusBox.text += "\n" + "MAP COLUMNS: " + MAP_COLUMNS; 		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {	  	    //Loop through all the cells in the game map      for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)      {        for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)        {          //Find out which tile ID number is in          //the current cell. This will be either          //"00" (a platform) or "01" (sky)          var currentTile:int = map[mapRow][mapColumn];                    //"-1" means that the tile destination grid will be blank          //This example doesn't use any blank tiles          if(currentTile > -1)          {            //Find the tile's column and row position            //on the tile sheet            var tileSheetColumn:uint               = uint(currentTile / 10);            var tileSheetRow:uint               = uint(currentTile % 10);                        //Now the code checks what type of tile            //the ID numbers says should be in the            //game map's grid cell            switch (currentTile)             {              case PLATFORM:                //If it finds a match it creates                //a TileModel object                var platform:TileModel = new TileModel();                platform.tileSheetColumn = tileSheetColumn;        	      platform.tileSheetRow = tileSheetRow;                platform.mapRow = mapRow;                platform.mapColumn = mapColumn;                platform.width = MAX_TILE_SIZE;                platform.height = MAX_TILE_SIZE;                platform.setX = mapColumn * MAX_TILE_SIZE;        	      platform.setY = mapRow * MAX_TILE_SIZE;  	                	      //Blit the tile from the tile sheet onto the        	      //background bitmap using the        	      //drawGameObject method        	      drawGameObject(platform, _backgroundBitmapData);                break;                              case SKY:                //Create a TileModel object                var sky:TileModel = new TileModel();                sky.tileSheetColumn = tileSheetColumn;        	      sky.tileSheetRow = tileSheetRow;                sky.mapRow = mapRow;                sky.mapColumn = mapColumn;                sky.width = MAX_TILE_SIZE;                sky.height = MAX_TILE_SIZE;                sky.setX = mapColumn * MAX_TILE_SIZE;        	      sky.setY = mapRow * MAX_TILE_SIZE;  	                	      //Blit the tile from the tile sheet onto the        	      //background bitmap         	      drawGameObject(sky, _backgroundBitmapData);                break;           }         }       }     }   }      //Basic blit method   private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle 		    = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   		    tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point   	    = new Point        (          tileModel.xPos,           tileModel.yPos        );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}