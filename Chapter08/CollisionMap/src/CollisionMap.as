package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import flash.geom.Matrix;  import flash.utils.getTimer;  import com.friendsofed.utils.*;  import com.friendsofed.vector.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="640", height="512",   backgroundColor="#FFFFFF", frameRate="60")]  	public class CollisionMap extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 10;	  private const MAP_ROWS:uint = 8;	  	  //tile ID numbers in tile sheet	  private const PLAYER:uint = 02;	  private const BIG_CIRCLE:uint = 12;	  	  private var _gameObjectMap:Array	    = [          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,12,-1,12,02,-1,12,-1,12,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,12,-1,12,-1,-1,12,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,12,-1,-1,-1,-1,12,-1,-1],          [-1,-1,-1,-1,12,-1,-1,-1,12,-1],          [-1,12,-1,-1,-1,-1,12,-1,-1,-1],        ];         	  /*	  private var _gameObjectMap:Array	    = [          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,02,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,12,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],          [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        ];     */   	  private var _circles:Array = new Array();	  	  //Create stage bitmap    private var _stageBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _stageBitmap:Bitmap       = new Bitmap(_stageBitmapData);        	//Tile sheet  	//Variables required to display the tile sheet bitmap		[Embed(source="../../images/tileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Create a TileModel to represent the player    private var _playerModel:TileModel;    private var _UIController:UIController;  	private var _UIView:UIView;		  		//Create a collision Controller to handle the collision		//between the player and the platforms		//You'll find the TileCollisionController in the		//com.friendsofed.utils package		private var _collisionController:TileCollisionController		 = new TileCollisionController();          //Status box  	private var _statusBox:StatusBox = new StatusBox;  	  	//Grid Display  	/*  	private var _grid:GridDisplay   	  = new GridDisplay  	  (  	    64, stage.stageWidth, stage.stageHeight  	  );		*/				public function CollisionMap():void		{  		  //Draw the tile sheet objects			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the stage bitmap			addChild(_stageBitmap);						//Add the status box			addChild(_statusBox);						//Add the grid display			//addChild(_grid);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_gameObjectMap);				addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{ 		  		  //Clear the stage bitmap from the previous frame so that it's		  //blank when you add the new tile positions		  _stageBitmapData.fillRect(_stageBitmapData.rect, 0);             //Initialize a blank collision map         var collisionMap:Array 		    = [            [[],[],[],[],[],[],[],[],[],[]],            [[],[],[],[],[],[],[],[],[],[]],            [[],[],[],[],[],[],[],[],[],[]],            [[],[],[],[],[],[],[],[],[],[]],            [[],[],[],[],[],[],[],[],[],[]],            [[],[],[],[],[],[],[],[],[],[]],            [[],[],[],[],[],[],[],[],[],[]],            [[],[],[],[],[],[],[],[],[],[]],          ];                  //Loop through all the circles.      //Add them to the collision map      //and check neighbouring cells for other circles		  for(var i:int = 0; i < _circles.length; i++)      {        //A reference to the current circle        var circle:TileModel = _circles[i];                //Update the circle and check stage bounds        circle.update();        StageBoundaries.bounceBitmap(circle, stage);                 //If this is the *first* circle, add it to the        //collision map, but don't bother checking        //for collisions because there won't yet be any other        //objects in the collision map to check for        if(i == 0)        {          collisionMap[circle.mapRow][circle.mapColumn].push(circle);        }        else        {          //Check the 8 cells surrounding this circle          //as well as the cell it currently occupies          //(9 cells in total)          for(var column:int = -1; column < 2; column++)          {            for(var row:int = -1; row < 2; row++)            {              /*              trace              (                "Column: " + int(circle.mapColumn + column)                + ","                 + "Row: " + int(circle.mapRow + row)              );              */                          //Make sure that the code doesn't               //check for rows that              //are greater than the number of rows               //and columns on the map              if(circle.mapRow + row < collisionMap.length              && circle.mapRow + row >= 0              && circle.mapColumn + column < collisionMap[0].length              && circle.mapColumn + column >= 0)              {                //Get a reference to this cell                //and cast it as an Array                 //(the compiler needs that reassurance)                var cell:Array                   = collisionMap                  [circle.mapRow + row]                  [circle.mapColumn + column]                   as Array;                                //If this cell isn't null, it must contain objects                if(cell != null)                {                  //Loop through all the elements in the cell                  //(It will usually just contain one object,                  //but you never know...)                  for                    (                      var element:int = 0;                       element < cell.length;                      element++                    )                  {                    //Check whether the current element is                     //a tile that we're interested in.                    //(You don't need to check for the existence                    //of the circle that's performing the check                    //because it hasn't been added to the array yet)                    if(cell[element].id == BIG_CIRCLE                    || cell[element].id == PLAYER)                    {                      //A possible collision!                      //Get a reference to the object that                      //might be involved in a collision                      var circle2:TileModel = cell[element];                                            //Do a narrow phase, distance based                       //collision check against the two circles                      _collisionController.movingCircleCollision                        (circle, circle2);                      /*                        trace                      (                        "Found: "                          + int(circle.mapColumn + column)                         + ", "                         + int(circle.mapRow + row)                         + ", C2: " + circle2.id                         + ", C1: " + circle.id                      )                       */                    }                  }                }              }            }            }        }          //Add the circle to the collision map        //in the same position as its current        //game map position.         collisionMap[circle.mapRow][circle.mapColumn].push(circle);        //trace("Circle " + i + " added")      }		  		  //Update the display		  for(var j:int = 0; j < _circles.length; j++)      {        drawGameObject(_circles[j], _stageBitmapData);      }      		  //Update status box			_statusBox.text = "COLLISION MAP:" + "\n"; 				 for			   (			     var mapRow:int = 0; 			     mapRow < MAP_ROWS; 			     mapRow++			   )         {        for          (            var mapColumn:int = 0;             mapColumn < MAP_COLUMNS;             mapColumn++          )        {                      if(collisionMap[mapRow][mapColumn][0] is TileModel)          {            _statusBox.text               += collisionMap[mapRow][mapColumn][0].id + ",";          }          else          {            _statusBox.text += "--,"          }          if(mapColumn == collisionMap[mapRow].length -1)          {            _statusBox.text += "\n";          }        }      }		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {      for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)      {        for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)        {          var currentTile:int = map[mapRow][mapColumn];                  if(currentTile > -1)          {            //Find the tile's column and row position            //on the tile sheet            var tileSheetColumn:uint               = uint(currentTile / 10);            var tileSheetRow:uint               = uint(currentTile % 10);                        switch(currentTile)            {              case PLAYER:                _playerModel      	          = new TileModel      	          (      	            MAX_TILE_SIZE,      	            tileSheetColumn, tileSheetRow,       	            mapRow, mapColumn,       	            48, 48      	          );       	        //_playerModel.gravity_Vy = 0.98;  	              	        //Add the UIView and UIController        	        _UIController       	          = new UIController(_playerModel);    	          _UIView     	            = new UIView(_playerModel, _UIController, stage);		            		            _circles.push(_playerModel);      	        drawGameObject(_playerModel, _stageBitmapData);      	        break;                        case BIG_CIRCLE:                var bigCircle:TileModel                   = new TileModel                  (                    MAX_TILE_SIZE,                    tileSheetColumn, tileSheetRow,       	            mapRow, mapColumn,       	            MAX_TILE_SIZE, MAX_TILE_SIZE                  );                _circles.push(bigCircle);                  drawGameObject(bigCircle, _stageBitmapData);                break;            }          }        }      }    }				private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   			  tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point = new Point      (        tileModel.xPos,         tileModel.yPos      );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}