package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import flash.geom.Matrix;  import flash.utils.getTimer;  import com.friendsofed.utils.*;  import com.friendsofed.vector.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="640", height="512",   backgroundColor="#FFFFFF", frameRate="60")]  	public class Scrolling extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 20;	  private const MAP_ROWS:uint = 16;	  	  private const PLATFORM:uint = 00;	  private const SKY:uint = 10;	  private const CAT:uint = 20;	  private const SOFT_PLATFORM:uint = 01;	 	  private var _platformMap:Array	    = [	      [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],        [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],        [10,10,10,10,10,10,10,10,10,10,10,10,10,00,10,10,10,10,10,00],        [10,10,10,10,10,01,01,10,00,00,10,00,00,00,10,10,10,10,00,00],        [10,10,10,10,10,10,10,10,00,10,10,10,10,00,10,10,10,00,00,00],        [10,10,10,10,10,01,01,10,00,00,00,10,10,00,10,10,10,10,10,10],        [10,10,10,10,10,10,10,10,00,00,00,10,10,00,00,00,10,10,10,10],        [10,00,10,10,00,00,00,10,00,00,00,10,10,00,10,10,10,00,00,10],        [10,10,10,10,10,10,10,10,00,10,10,10,00,00,10,10,10,10,10,10],        [10,10,10,00,00,10,10,00,00,10,10,00,00,00,00,00,00,10,10,10],        [10,10,10,10,10,10,10,00,10,10,00,00,00,00,10,10,10,10,10,10],        [10,10,10,10,10,00,00,00,10,10,00,00,00,00,10,10,10,00,00,10],        [10,10,10,10,10,10,00,00,10,10,10,10,00,10,10,10,10,10,10,10],        [10,10,10,10,00,00,00,10,10,10,10,10,00,10,10,00,00,00,10,10],        [10,00,00,10,10,10,00,10,10,10,10,10,10,10,10,10,10,10,10,10],        [00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00]	      ];    	      	  private var _gameObjectMap:Array      = [        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],        ];          	  //Create blank BitmapData objects as the canvas for this game    private var _backgroundBitmapData:BitmapData       = new BitmapData        (          MAP_COLUMNS * MAX_TILE_SIZE,           MAP_ROWS * MAX_TILE_SIZE,           true, 0        );            private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);          private var _foregroundBitmapData:BitmapData        = new BitmapData        (          MAP_COLUMNS * MAX_TILE_SIZE,           MAP_ROWS * MAX_TILE_SIZE,           true, 0        );    private var _foregroundBitmap:Bitmap       = new Bitmap(_foregroundBitmapData);          //A rectangle that will act as a camera onto the     //scrolling environment      private var _camera:Rectangle = new Rectangle  		(0, 0, stage.stageWidth, stage.stageHeight);  	  	//Tile sheet		[Embed(source="../../images/tileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Create a TileModel to represent the cat    private var _catModel:TileModel;    private var _UIPlatformController:UIPlatformController;    private var _UIPlatformView:UIPlatformView;		  		//Create a collision Controller 		private var _collisionController:TileCollisionController		 = new TileCollisionController();          private var _currentTile:uint = 0;    private var _mapRow:uint = 0;    private var _mapColumn:uint = 0;        //Status box  	private var _statusBox:StatusBox = new StatusBox;				public function Scrolling():void		{  		  //Draw the tile sheet			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the stage bitmaps			addChild(_backgroundBitmap);			addChild(_foregroundBitmap);						//Add the status box			addChild(_statusBox);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_platformMap);			buildMap(_gameObjectMap);				addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}		private function enterFrameHandler(event:Event):void		{ 		  //Update the cat's Model		  _catModel.update();		  		  //Stop the cat at the stage boundaries		  //StageBoundaries.stopBitmap(_catModel, stage); 		  		  if(_catModel.yPos + _catModel.height 		    >= _foregroundBitmapData.height)		  {		    _catModel.jumping = false;		  }		  		  //Clear the stage bitmap from the previous frame so that it's		  //blank when you add the new tile positions		  _foregroundBitmapData.fillRect(_foregroundBitmapData.rect, 0);		  		  //Check for collisions with the platforms		  _collisionController.platformCollision		    (_catModel, _platformMap, MAX_TILE_SIZE, PLATFORM);		  		  //Check for collisions with the soft platforms		  _collisionController.softPlatformCollision		    (_catModel, _platformMap, MAX_TILE_SIZE, SOFT_PLATFORM);              //Set up the camera to focus on the cat		  _camera.x = _catModel.xPos - stage.stageWidth * 0.5;		  _camera.y = _catModel.yPos - stage.stageHeight * 0.5;		  		  //Check the camera's game world boundaries		  //Left		  if(_camera.x < 0)		  {		    _camera.x = 0;		  }		  		  //Right		  if(_camera.x > (MAP_COLUMNS * MAX_TILE_SIZE) 		    - stage.stageWidth)		  {		    _camera.x = (MAP_COLUMNS * MAX_TILE_SIZE) - stage.stageWidth;		  }		  		  //Bottom		  if(_camera.y > (MAP_ROWS * MAX_TILE_SIZE) - stage.stageHeight)		  {		    _camera.y = (MAP_ROWS * MAX_TILE_SIZE) - stage.stageHeight;		  }		  		  //Top		  if(_camera.y < 0)		  {		    _camera.y = 0;	    }	    	    //Blit the cat on the foreground bitmap		  drawGameObject(_catModel, _foregroundBitmapData);		  		  //Scroll the game world		  _foregroundBitmap.scrollRect = _camera;		  _backgroundBitmap.scrollRect = _camera;		  		  //Update the status box			_statusBox.text = "SCROLLING:"; 			_statusBox.text += "\n" + "CAMERA X: " + _camera.x;			_statusBox.text += "\n" + "CAMERA Y: " + _camera.y;			_statusBox.text += "\n" + "CAT X: " + _catModel.xPos;			_statusBox.text += "\n" + "STAGE MOUSE X: " + mouseX;			_statusBox.text 			  += "\n" + "BITMAP MOUSE X: " + _backgroundBitmap.mouseX;		 }				//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {      for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)      {        for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)        {          var currentTile:int = map[mapRow][mapColumn];                  if(currentTile > -1)          {            //Find the tile's column and row position            //on the tile sheet            var tileSheetColumn:uint               = uint(currentTile / 10);            var tileSheetRow:uint               = uint(currentTile % 10);                        switch(currentTile)            {              case CAT:                _catModel      	          = new TileModel      	          (      	            MAX_TILE_SIZE,      	            tileSheetColumn, tileSheetRow,       	            mapRow, mapColumn,       	            48, 42      	          );   	                	        //Add some gravity        	        _catModel.gravity_Vy = 0.98;      	              	        //Set the cat's coordinateSpace       	        //to the _foregroundBitmap.      	        //This means mouse tracking will be acccurate      	        _catModel.coordinateSpace = _foregroundBitmap;  	              	        //Add the UIView and UIController        	        _UIPlatformController      	          = new UIPlatformController(_catModel);    	          _UIPlatformView    		          = new UIPlatformView    		          (_catModel, _UIPlatformController, stage);  		                	        drawGameObject(_catModel, _foregroundBitmapData);      	        break;                        case PLATFORM:                var platform:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,    	            tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE                );    	          drawGameObject(platform, _backgroundBitmapData);                break;                          case SKY:                var sky:TileModel                   = new TileModel                  (                    MAX_TILE_SIZE,    	              tileSheetColumn, tileSheetRow,       	            mapRow, mapColumn,       	            MAX_TILE_SIZE, MAX_TILE_SIZE                  );    	          drawGameObject(sky, _backgroundBitmapData);                break;                            case SOFT_PLATFORM:               var softPlatform:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,                  tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE                );    	        drawGameObject(softPlatform, _backgroundBitmapData)              break;             }         }       }     }   }				private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   			  tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point = new Point      (        tileModel.xPos,         tileModel.yPos      );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}