package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import flash.geom.Matrix;  import com.friendsofed.utils.*;  import com.friendsofed.vector.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="640", height="512",   backgroundColor="#FFFFFF", frameRate="60")]  	public class Character extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 10;	  private const MAP_ROWS:uint = 8;	  	  //The PLATFORM and SKY constants define	  //the position of tile images in tile sheet	  private const PLATFORM:uint = 00;	  private const SKY:uint = 10;	  	  //The CAT constant defines the position	  //of the cat in the tile sheet	  private const CAT:uint = 20;	 	  private var _platformMap:Array	    = [	        [10,10,10,10,10,10,10,10,10,10],	        [00,00,10,10,10,10,10,10,10,10],	        [10,10,10,10,10,00,00,00,00,10],	        [10,10,00,10,10,10,10,10,10,10],	        [10,10,10,10,10,10,10,10,10,10],	        [00,00,00,00,10,10,10,00,10,10],	        [00,00,00,00,00,10,10,10,10,10],	        [00,00,00,00,00,00,00,00,00,00]	      ]    	  	  private var _gameObjectMap:Array	    = [	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,20,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	      ]        	   	  //Create blank BitmapData objects as the canvas for this bitmap	  //They are in two layers: background for static objects	  //like the scenery, and forground for moving objects    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);    private var _foregroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _foregroundBitmap:Bitmap       = new Bitmap(_foregroundBitmapData);  	  	//Tile sheet  	//Variables required to display the tile sheet bitmap		[Embed(source="../../images/tileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			(		    _tileSheetImage.width, 		    _tileSheetImage.height, 		    true, 		    0		  );		private var _catModel:TileModel;	          //Status box  	private var _statusBox:StatusBox = new StatusBox;				public function Character():void		{  		  //Draw the BitmapData objects			//_catBitmapData.draw(_catImage);			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the stage bitmap		  //this displays the contents of the _backgroundBitmapData		  //It will be updated automatically when		  //the _backgroundBitmapData is changed			addChild(_backgroundBitmap);			addChild(_foregroundBitmap);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_platformMap);			buildMap(_gameObjectMap);						//Add the status box			addChild(_statusBox);						//Update status box			_statusBox.text = "CHARACTER:"; 			_statusBox.text += "\n" + "TILE SIZE: " + MAX_TILE_SIZE; 			_statusBox.text += "\n" + "MAP ROWS: " + MAP_ROWS;  			_statusBox.text += "\n" + "MAP COLUMNS: " + MAP_COLUMNS; 			}			//Create tile Models and map them to the	//correct positions on the tile sheet	private function buildMap(map:Array):void	{    for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)    {      for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)      {        var currentTile:int = map[mapRow][mapColumn];                if(currentTile > -1)        {          //Find the tile's column and row position          //on the tile sheet          var tileSheetColumn:uint = uint(currentTile / 10);          var tileSheetRow:uint = uint(currentTile % 10);                    switch (currentTile)           {            case CAT:              _catModel  	            = new TileModel    	          (    	            MAX_TILE_SIZE,    	            tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            48, 42    	          );     	        drawGameObject(_catModel, _foregroundBitmapData);              break;                      case PLATFORM:              //If it finds a match it creates              //a TileModel object              var platform:TileModel = new TileModel();              platform.tileSheetColumn = tileSheetColumn;      	      platform.tileSheetRow = tileSheetRow;              platform.mapRow = mapRow;              platform.mapColumn = mapColumn;              platform.width = MAX_TILE_SIZE;              platform.height = MAX_TILE_SIZE;              platform.setX = mapColumn * MAX_TILE_SIZE;      	      platform.setY = mapRow * MAX_TILE_SIZE;	              	      //Blit the tile from the tile sheet onto the      	      //background bitmap using the      	      //drawGameObject method      	      drawGameObject(platform, _backgroundBitmapData);              break;                          case SKY:              //Create a TileModel object              var sky:TileModel = new TileModel();              sky.tileSheetColumn = tileSheetColumn;      	      sky.tileSheetRow = tileSheetRow;              sky.mapRow = mapRow;              sky.mapColumn = mapColumn;              sky.width = MAX_TILE_SIZE;              sky.height = MAX_TILE_SIZE;              sky.setX = mapColumn * MAX_TILE_SIZE;      	      sky.setY = mapRow * MAX_TILE_SIZE;	              	      //Blit the tile from the tile sheet onto the      	      //background bitmap       	      drawGameObject(sky, _backgroundBitmapData);              break;          }        }      }    }   }   //Basic blit method   private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle 		    = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   		    tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point   	    = new Point        (          tileModel.xPos,           tileModel.yPos        );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}