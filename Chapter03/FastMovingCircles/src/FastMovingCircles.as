package{	import flash.events.Event;  import flash.display.Sprite;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class FastMovingCircles extends Sprite	{			//Circle 1 (player's circle)  		private var _c1:CircleModel   		  = new CircleModel(3);  		private var _UIController:UIController   		  = new UIController(_c1);  		private var _c1_View:CircleView   		  = new CircleView(_c1);  		private var _UIView:UIView   		  = new UIView(_c1, _UIController, stage);  		  		//Circle 2  		private var _c2:CircleModel   		  = new CircleModel(3);  		private var _c2_View:CircleView   		  = new CircleView(_c2);  		  		//Variables to help test for a collision  		private var _withinTrajectory:Boolean = false;  		private var _collision:Boolean = false;  		//Status box  		private var _statusBox:StatusBox = new StatusBox;				public function FastMovingCircles():void		{ 		  //Circle 1			addChild(_c1_View);			_c1.setX = 300;			_c1.setY = 200;						//Circle 2			addChild(_c2_View);			_c2.setX = 200;			_c2.setY = 200;		  		  //Add the status box			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{  			//Update c1 (player's circle)			_c1.update();			StageBoundaries.bounce(_c1, stage);       						//Update c2			_c2.update();			StageBoundaries.bounce(_c2, stage);						graphics.clear();  	  graphics.lineStyle(1);  		graphics.moveTo(_c1.xPos, _c1.yPos);   		graphics.lineTo(mouseX, mouseY);			      //Vector between circles			var v0:VectorModel 			  = new VectorModel(_c1.xPos, _c1.yPos, _c2.xPos, _c2.yPos); 						//c1's motion vector			var v1:VectorModel 			  = new VectorModel			  (			    _c1.xPos, 			    _c1.yPos, 			    _c1.xPos + _c1.vx, 			    _c1.yPos + _c1.vy			  );			                                     		  //c2's motion vector      var v2:VectorModel         = new VectorModel        (          _c2.xPos,           _c2.yPos,           _c2.xPos + _c2.vx,           _c2.yPos + _c2.vy        );                                                 //Two motion vectors are difficult to deal with.      //Simplify this problem      //by creating a new vector, v3                                     var v3:VectorModel         = new VectorModel        (          0,0,0,0,           _c1.vx - _c2.vx,           _c1.vy - _c2.vy        );            //Project v0 onto v3.       //This gives you the closest      //point of c1 to c2                                     			var p1:VectorModel = VectorMath.project(v0, v3); 						//Plot a vector from p1.b to the center of c2			var v4:VectorModel 			  = new VectorModel			  (			    _c1.xPos + p1.vx, 			    _c1.yPos + p1.vy, 			    _c2.xPos, 			    _c2.yPos			  );						//Calculate the radii of both circles combined			var totalRadii:Number = _c1.radius + _c2.radius;						//Find the difference between the total radii 			//and the magnitude of v4			var difference:Number = totalRadii - v4.m;                                         if(difference > 0)			{			  //Possible collision! c1 is in a trajectory that may			  //intersect with c2. Let's find out if it does...			  _withinTrajectory = true			  var overlap:Number			    = Math.sqrt(totalRadii * totalRadii - v4.m * v4.m);			                                 			  //Find the possible new position for c1                               			  var new_X:Number =  v4.a.x - overlap * v3.dx;			  var new_Y:Number =  v4.a.y - overlap * v3.dy;					  //Create a vector between v1.a and the new x and y points			  var v5:VectorModel 			    = new VectorModel(_c1.xPos, _c1.yPos, new_X, new_Y);         			  			  //Find the dot product between v0 and v1  			var dp:Number = VectorMath.dotProduct2(v5, v1);  					  if(v5.m < v3.m  			&& dp > 0)  			{  			  //The motion vectors will intersect in the next frame  			  //so the circles will definitely collide  			  _collision = true;  			  var ratio:Number = v5.m / v3.m;  			    			  //Move the circles to the collision point  			  _c1.setX = _c1.xPos + ratio * _c1.vx;          _c1.setY = _c1.yPos + ratio * _c1.vy;                    _c2.setX = _c2.xPos + ratio * _c2.vx;          _c2.setY = _c2.yPos + ratio * _c2.vy;                   //Bounce them apart          //Project v1 onto v0 and v0.ln                                                                                    var p1a:VectorModel = VectorMath.project(v1, v0);          var p1b:VectorModel = VectorMath.project(v1, v0.ln);                        //Project v2 onto v0 and v0.ln          var p2a:VectorModel = VectorMath.project(v2, v0);          var p2b:VectorModel = VectorMath.project(v2, v0.ln);                       //Mix and match the results of p1 and p2 to           //find the correct bounce vectors                  //Bounce c1          //p1b and p2a          _c1.vx = p1b.vx + p2a.vx;           _c1.vy = p1b.vy + p2a.vy;                   //Bounce c2          //p1a and p2b          _c2.vx = p1a.vx + p2b.vx;          _c2.vy = p1a.vy + p2b.vy;			  }			  else			  {			    _collision = false;			  }    			}			else			{			  _withinTrajectory = false;			}			//Update status box			_statusBox.text = "FAST MOVING CIRCLES:";					_statusBox.text 			  += "\n" + "DIFFERNCE: " 			  + Math.round(difference * 1000) / 1000;			_statusBox.text 			  += "\n" + "WITHIN TRAJECTORY: " + _withinTrajectory;		  _statusBox.text += "\n" + "COLLISION: " + _collision;		}	}}