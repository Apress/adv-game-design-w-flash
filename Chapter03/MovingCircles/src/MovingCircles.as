package{	import flash.events.Event;  import flash.display.Sprite;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class MovingCircles extends Sprite	{			//Circle 1 (player's circle), with a radius of 30  		private var _c1:CircleModel   		  = new CircleModel(30);  		private var _UIController:UIController   		  = new UIController(_c1);  		private var _c1_View:CircleView   		  = new CircleView(_c1);  		private var _UIView:UIView   		  = new UIView(_c1, _UIController, stage);  		  		//Circle 2, with a radius of 100  		private var _c2:CircleModel = new CircleModel(100);  		private var _c2_View:CircleView = new CircleView(_c2);  		//Status box  		private var _statusBox:StatusBox = new StatusBox;				public function MovingCircles():void		{ 		  //Circle 1			addChild(_c1_View);			_c1.setX = 300;			_c1.setY = 200;			_c1.gravity_Vy = 0.1;			//_c1.friction = 1;						//Circle 2			addChild(_c2_View);			_c2.setX = 200;			_c2.setY = 200;			_c2.gravity_Vy = 0.1;			//_c2.friction = 1;		  		  //Add the status box			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{ 			//Update c1 (player's circle)			_c1.update();			StageBoundaries.bounce(_c1, stage);       						//Update c2			_c2.update();			StageBoundaries.bounce(_c2, stage);			      //Vector between circles			var v0:VectorModel 			  = new VectorModel(_c1.xPos, _c1.yPos, _c2.xPos, _c2.yPos);                               						//Calculate the radii of both circles combined			var totalRadii:Number = _c1.radius + _c2.radius;                             						if(v0.m < totalRadii)			{ 			  //A collision is occuring.			  //Find the amount of overlap			  var overlap:Number = totalRadii - v0.m;			  			  //Create an overlap vector			  var collision_Vx:Number = Math.abs(v0.dx * overlap * 0.5);        var collision_Vy:Number = Math.abs(v0.dy * overlap * 0.5);								//Varibales that track whether _c1 is above, below,				//to the left or to the right of _c1				var xSide:int;				var ySide:int;								//xSide is "1" when _c1 is to the right of _c2, 				//and "-1" when it's to the left of _c2.				//ySide is "1" when _c1 is below _c2, 				//and "-1" when it's above _c2.			  _c1.xPos > _c2.xPos ? xSide = 1 : xSide = -1;				_c1.yPos > _c2.yPos ? ySide = 1 : ySide = -1;									//Reposition _c1 out of the collision				//Use xSide and ySide to make the overlap vector either				//negative or positive, depending on the side of the collision				_c1.setX = _c1.xPos + (collision_Vx * xSide);        _c1.setY = _c1.yPos + (collision_Vy * ySide);                //Reposition _c2         _c2.setX = _c2.xPos + (collision_Vx * -xSide);        _c2.setY = _c2.yPos + (collision_Vy * -ySide);				          //We’ve moved the circles out of the collision, now we        //need to bounce them away at the correct angle				        //c1's motion vector  			var v1:VectorModel   			  = new VectorModel  			  (  			    _c1.xPos,   			    _c1.yPos,   			    _c1.xPos + _c1.vx,   			    _c1.yPos + _c1.vy  			  );  			                                       			//c2's motion vector        var v2:VectorModel           = new VectorModel          (            _c2.xPos, _c2.yPos,             _c2.xPos + _c2.vx,             _c2.yPos + _c2.vy          );                //Project v1 onto v0 and v0.ln                                                                                  var p1a:VectorModel = VectorMath.project(v1, v0);        var p1b:VectorModel = VectorMath.project(v1, v0.ln);                      //Project v2 onto v0 and v0.ln        var p2a:VectorModel = VectorMath.project(v2, v0);        var p2b:VectorModel = VectorMath.project(v2, v0.ln);                     //Mix and match the results of p1 and p2 to         //find the correct bounce vectors                //Bounce c1        //p1b and p2a        _c1.vx = p1b.vx + p2a.vx;         _c1.vy = p1b.vy + p2a.vy;                 //Bounce c2        //p1a and p2b                _c2.vx = p1a.vx + p2b.vx;        _c2.vy = p1a.vy + p2b.vy;                //To add mass, divide the bounce vector        //by some number        //var mass:uint = 5;        //_c2.vx = (p1a.vx + p2b.vx) / mass;        //_c2.vy = (p1a.vy + p2b.vy) / mass;			}			//Update status box			_statusBox.text = "MOVING CIRCLES";		}	}}