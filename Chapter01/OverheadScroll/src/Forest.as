package{	import utils.*;	import flash.display.*;	import flash.filters.*;	import flash.events.Event;		//Required for creating a gradient fill	import flash.display.GradientType;	import flash.geom.Matrix;	public class Forest extends MovieClip	{		private const BACKGROUND_SIZE = 1000;		private var _numberOfTrees:uint;		private var _background:Shape;				//Variables required for Verlet integration		private var _vx:Number;		private var _vy:Number;		private var _oldX:Number;		private var _oldY:Number;		private var _xPos:Number;		private var _yPos:Number;		private var _temporaryX:Number;		private var _temporaryY:Number;		public function Forest(numberOfTrees:uint = 60)		{			_vx = 0;			_vy = 0;			_xPos = 0;			_yPos = 0;			_oldX = 0;			_oldY = 0;			_temporaryX = 0;			_temporaryY = 0;						this._numberOfTrees = numberOfTrees;						addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}		private function onAddedToStage(event:Event):void		{			_background = new Shape();			_background.graphics.lineStyle(30);			_background.graphics.drawRect(-BACKGROUND_SIZE/2, -BACKGROUND_SIZE/2, BACKGROUND_SIZE, BACKGROUND_SIZE);			addChild(_background);						//Randomly plot the trees			for (var i:uint = 0; i < Math.round(_numberOfTrees); i++)			{				//Create a new star and position it randomly				var tree:Tree = new Tree();				tree.x = Math.random() * 1000;				tree.y = Math.random() * 1000;				addChild(tree);			}					}		private function onRemovedFromStage(event:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}		public function update():void		{			//Verlet integration in action:			//1. Temporarily store the current x and y positions			_temporaryX = _xPos;			_temporaryY = _yPos;						//Add the x and y speed to the velocity			//vx = _xSpeed;			//vy = _ySpeed;						//2. Apply the velocity to the position			//The public vx and vy getters and setter			//dynamically calculate velocity based on			//the difference between the current position			//and the old position			_xPos += vx;			_yPos += vy;						//3. The previous position becomes the			//old position which is used calculate velocity			_oldX = _temporaryX;			_oldY = _temporaryY;		}				//Public properties		public function set vx(value:Number):void		{			_oldX = _xPos - value;		}		public function get vx():Number		{			return _xPos - _oldX;		}		//vy		public function set vy(value:Number):void		{			_oldY = _yPos - value;		}		public function get vy():Number		{			return _yPos - _oldY;		}		//xPos		public function set xPos(value:Number):void		{			_xPos = value;		}		public function get xPos():Number		{			return _xPos;		}		//yPos		public function set yPos(value:Number):void		{			_yPos = value;		}		public function get yPos():Number		{			return _yPos;		}		//setX		public function set setX(value:Number):void		{			_oldX = value;			_xPos = value;		}		//setY		public function set setY(value:Number):void		{			_oldY = value;			_yPos = value;		}	}}