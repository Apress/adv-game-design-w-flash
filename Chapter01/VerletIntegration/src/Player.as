package{	import flash.display.*;	import flash.events.Event;	import flash.filters.*;		//Keyboard Events	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	public class Player extends Sprite	{		private const SPEED:uint = 10;		private var _shape:Shape;		//Variables required for Verlet integration		private var _previousX:Number = 0;		private var _previousY:Number = 0;		private var _temporaryX:Number = 0;		private var _temporaryY:Number = 0;		public var xPos:Number = 0;		public var yPos:Number = 0;		public function Player():void		{				addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}				private function onAddedToStage(event:Event):void		{			//Draw the player			draw();						//Add listeners			addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);			stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);						//Remove the onAddedToStageHandler			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}				private function onRemovedFromStage(event:Event):void		{			removeEventListener			  (Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}				private function draw():void		{ 		  //Draw the outer shape			var outerShape:Shape = new Shape();			outerShape.graphics.beginFill(0x000000);			outerShape.graphics.drawRoundRect(-25, -25, 50, 50, 10, 10);			outerShape.graphics.endFill();			addChild(outerShape);						//Add a bevel and drop shadow and bevel filter			var outerFilters:Array = outerShape.filters;			outerFilters.push		    (		      new BevelFilter		      (5, 135, 0xFFFFFF, 0.50, 0x999999, 0.50, 2, 2)		    );			outerFilters.push			  (			    new DropShadowFilter			    (5, 135, 0x000000, 0.60,10, 10)			  );			outerShape.filters = outerFilters;						//Draw the inner shape			var innerShape:Shape = new Shape();			innerShape.graphics.beginFill(0xCCCCCC);			innerShape.graphics.drawCircle(0, 0, 15);			innerShape.graphics.endFill();			addChild(innerShape);						//Add a bevel and drop shadow and bevel filter			var innerFilters:Array  = innerShape.filters;			innerFilters.push			  (			    new BevelFilter			    (3, 315, 0xFFFFFF, 0.50, 0x999999, 0.50, 4, 4, 1, 1,"outer")			  );			innerShape.filters = innerFilters;		}			private function onKeyDown(event:KeyboardEvent):void  	{  		if (event.keyCode == Keyboard.LEFT)  		{  			vx = -SPEED;  		}  		if (event.keyCode == Keyboard.RIGHT)  		{  			vx = SPEED;  		}  		if (event.keyCode == Keyboard.UP)  		{  			vy = -SPEED;  		}  		if (event.keyCode == Keyboard.DOWN)  		{  			vy = SPEED;  		}  	}		private function onKeyUp(event:KeyboardEvent):void		{			if (event.keyCode == Keyboard.LEFT 			|| event.keyCode == Keyboard.RIGHT)			{				vx = 0;			}			if (event.keyCode == Keyboard.UP 			|| event.keyCode == Keyboard.DOWN)			{				vy = 0;			}		}			//The update function is called by the application class's		//onEnterFrame event		public function update():void		{			//Verlet integration in action:			//1. Temporarily store the current x and y positions			_temporaryX = xPos;			_temporaryY = yPos;						//2. Move the object			xPos += vx;			yPos += vy;						//3. The position before the object was moved becomes the			//previous position which is used calculate velocity			_previousX = _temporaryX;			_previousY = _temporaryY;		}				//Getters and setters		//vx		public function get vx():Number		{			return xPos - _previousX;		}		public function set vx(value:Number):void		{			_previousX = xPos - value;		}				//vy		public function get vy():Number		{			return yPos - _previousY;		}		public function set vy(value:Number):void		{			_previousY = yPos - value;		}				//setX		public function set setX(value:Number):void		{			_previousX = value - vx;			xPos = value;		}				//setY		public function set setY(value:Number):void		{			_previousY = value - vy;			yPos = value;		}	}}