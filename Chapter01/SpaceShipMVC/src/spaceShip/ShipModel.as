package spaceShip{	import flash.events.Event;	import flash.events.EventDispatcher;		//Required for creating a gradient fill	import flash.display.GradientType;	import flash.geom.Matrix;	public class ShipModel extends EventDispatcher	{				private var _xPos:Number = 0;		private var _yPos:Number = 0;		private var _accelerationX:Number = 0;		private var _accelerationY:Number = 0;		private var _angle:Number = 0;		private var _rotationValue:Number = 0;		public var friction:Number = 0;		public var frictionX:Number = 0;		public var frictionY:Number = 0;		public var acceleration:Number = 0;		public var temporaryX:Number = 0;		public var temporaryY:Number = 0;		public var rotationSpeed:Number = 0;		public var previousX:Number = 0;		public var previousY:Number = 0;		public var direction:Number = 0;		public var height:uint = 30;		public var width:uint;		public var color:uint;		public var thrusterFired:Boolean = false;		public function ShipModel		  (		    color:uint = 0x99FF66, 		    size:uint = 30		  ):void 		{		  this.width = size;		  this.color = color;		}		public function update():void		{			//Temporarily store the current x and y positions			temporaryX = xPos;			temporaryY = yPos;						//Calculate the rotationValue			_rotationValue += rotationSpeed;						//Calculate the angle and acceleration			_angle = _rotationValue * (Math.PI / 180);			_accelerationX = Math.cos(_angle) * acceleration;			_accelerationY = Math.sin(_angle) * acceleration;						frictionX = vx * friction;			frictionY = vy * friction;						//Alternate friction equation			//frictionX = (xPos - previousX) * friction;			//frictionY = (yPos - previousY) * friction;						//Speed trap:Stop the object moving 			//if the up arrow isn't being pressed			//and its speed falls below 0.1						if(! thrusterFired)			{			  if((Math.abs(vx) < 0.1) && (Math.abs(vy) < 0.1))			  {				  _accelerationX = 0;				  _accelerationY = 0;				  frictionX = 0;				  frictionY = 0;			  }		  }      			//Apply acceleration to the			//public xPos and yPos properties			xPos += _accelerationX + frictionX;			yPos += _accelerationY + frictionY;						//The temporary values becomes the      //previous positions, which are used calculate velocity			previousX = temporaryX;			previousY = temporaryY;		}		//Getters and setters				//rotationValue		public function get rotationValue():Number		{			return _rotationValue;		}		public function set rotationValue(value:Number):void		{			_rotationValue = value;			dispatchEvent(new Event(Event.CHANGE));		}				//angle		public function get angle():Number		{			_angle = _rotationValue * (Math.PI / 180);			return _angle		}				//accelerationX		public function get accelerationX():Number		{			_accelerationX = Math.cos(_angle) * acceleration;			return _accelerationX;		}				//accelerationY		public function get accelerationY():Number		{			_accelerationY = Math.sin(_angle) * acceleration;			return _accelerationY;		}				//vx		public function get vx():Number		{			return _xPos - previousX;		}		public function set vx(value:Number):void		{			previousX = _xPos - value;		}				//vy		public function get vy():Number		{			return _yPos - previousY;		}		public function set vy(value:Number):void		{			previousY = _yPos - value;		}				//xPos		public function get xPos():Number		{			return _xPos;		}		public function set xPos(value:Number):void		{			_xPos = value;			dispatchEvent(new Event(Event.CHANGE));		}				//yPos		public function get yPos():Number		{			return _yPos;		}		public function set yPos(value:Number):void		{			_yPos = value;			dispatchEvent(new Event(Event.CHANGE));		}				//setX		public function set setX(value:Number):void		{			previousX = value - vx;			xPos = value;		}				//setY		public function set setY(value:Number):void		{			previousY = value - vy;			yPos = value;		}	}}