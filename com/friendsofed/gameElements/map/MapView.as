package com.friendsofed.gameElements.ufo{	import flash.display.*;	import flash.filters.*;	import flash.events.Event;	import com.friendsofed.gameElements.primitives.*;		//Required for creating a gradient fill	import flash.display.GradientType;	import flash.geom.Matrix;	public class UfoView extends AVerletView	{	  private var _thrusterShape:Shape = new Shape();	  private var _redDome:Shape = new Shape;	  private var _greenDome:Shape = new Shape;	  		public function UfoView(model:UfoModel):void		{		  super(model);		}		override protected function draw():void		{		  		  //1. Create the thruster		  //Create the gradient fill effect for the thruster			var matrix:Matrix = new Matrix();			matrix.createGradientBox(model.width/2, model.width/3, 			       (90*Math.PI/180), 0, -model.width/4);			var colors:Array = new Array();			colors = [0xFF3300, 0xFFFF00];			var alphas:Array = new Array();			alphas = [100, 0]; 			var ratios:Array = new Array();			ratios = [0, 255];						//1.Draw the thruster flame			_thrusterShape.graphics.lineStyle(1, 0x000000, 0);			_thrusterShape.graphics.beginGradientFill(GradientType.LINEAR, 			                        colors, alphas, ratios, matrix);			_thrusterShape.graphics.moveTo(model.width/4, -model.width/4); 			_thrusterShape.graphics.curveTo(model.width/2, model.width/2, 			                        (model.width/4 * 3), -model.width/4);			_thrusterShape.graphics.lineTo(model.width/4, -model.width/4);			_thrusterShape.graphics.endFill();						//Position the thruster so that it appears under the UFO			_thrusterShape.y = (model.height / 10) * 11;						//Make the thruster invisible when it's first drawn			_thrusterShape.visible = true;						//Add a blur filter to the thruster			var thrusterFilters:Array = new Array();			thrusterFilters = _thrusterShape.filters;			thrusterFilters.push(new BlurFilter(5,5,3));			_thrusterShape.filters = thrusterFilters;						var body:Shape = new Shape;						//Draw the body			body.graphics.beginFill(0x666666);			body.graphics.drawEllipse(0, model.height / 3, model.width, (model.height / 4) * 2);			body.graphics.endFill();						//Draw the left leg			body.graphics.beginFill(0x666666);			body.graphics.moveTo(model.width / 10, ((model.height / 10) * 7));			body.graphics.lineTo(0, model.height);			body.graphics.lineTo(((model.width / 10) * 3), ((model.height / 10) * 7));			body.graphics.lineTo(model.width / 10, ((model.height / 10) * 7));			body.graphics.endFill();						//Draw the right leg			body.graphics.beginFill(0x666666);			body.graphics.moveTo(((model.width / 10) * 7), ((model.height / 10) * 7));			body.graphics.lineTo(((model.width / 10) * 9), ((model.height / 10) * 7));			body.graphics.lineTo(model.width, model.height);			body.graphics.lineTo(((model.width / 10) * 7), ((model.height / 10) * 7));			body.graphics.endFill();							//Gradient and matrix for the dome's alpha fill colors			var domeMatrix:Matrix = new Matrix();			domeMatrix.createGradientBox(model.width, model.height, 			       0, 0, -model.height/6);			var redDomeColors:Array = new Array();			redDomeColors = [0xFF0033, 0x000000];			var greenDomeColors:Array = new Array();			greenDomeColors = [0x99FF33, 0x66CC00];			var domeAlphas:Array = new Array();			domeAlphas = [100, 0]; 			var domeRatios:Array = new Array();			domeRatios = [0, 255];						//Draw the red dome			_redDome.graphics.lineStyle(1, 0x666666);			_redDome.graphics.beginGradientFill(GradientType.RADIAL, redDomeColors, domeAlphas, domeRatios, domeMatrix);		  _redDome.graphics.moveTo(model.width / 8, model.height / 2);			_redDome.graphics.curveTo(model.width / 2, ((model.height / 3) * 2), ((model.width / 8) * 7), model.height / 2);			_redDome.graphics.curveTo(model.width / 2, 0 - model.height / 3, model.width / 8, model.height / 2);			_redDome.graphics.endFill();			_redDome.visible = false;						//Draw the green dome			_greenDome.graphics.lineStyle(1, 0x666666);			_greenDome.graphics.beginGradientFill(GradientType.RADIAL, greenDomeColors, domeAlphas, domeRatios, domeMatrix);		  _greenDome.graphics.moveTo(model.width / 8, model.height / 2);			_greenDome.graphics.curveTo(model.width / 2, ((model.height / 3) * 2), ((model.width / 8) * 7), model.height / 2);			_greenDome.graphics.curveTo(model.width / 2, 0 - model.height / 3, model.width / 8, model.height / 2);			_greenDome.graphics.endFill();						//body.width = model.width;			//body.height = model.height;						//Create a new sprite to contain the shapes			var ufo:Sprite = new Sprite();			ufo.addChild(_thrusterShape);			ufo.addChild(body);			ufo.addChild(_redDome);			ufo.addChild(_greenDome);			addChild(ufo);						//Add a bevel and drop shadow filters			/*			var filters:Array = [];			filters = ufo.filters;			filters.push(new BevelFilter(2, 135, 0xFFFFFF, 0.50, 			                     0x000000, 0.50, 2, 2));			filters.push(new DropShadowFilter(2, 135, 0x000000, 			                     0.35, 2, 2));			ufo.filters = filters;			*/			//Center the shape			//ufo.x -= model.width / 2;			//ufo.y -= model.height / 2;		}		override protected function changeHandler(event:Event):void		{		  //First call the default directives in AVerletView's changeHandler method			super.changeHandler(event);						//Add these new directives to the method:						//Display the thuster if the UFO is moving up			if(model.vy < 0			&& model.playerIsVisible)			{				_thrusterShape.visible = true;			}			else			{				_thrusterShape.visible = false;			}						//Change the color of the dome if the UFO's enemy (the player) is visible			if(model.playerIsVisible)			{				_redDome.visible = true;				_greenDome.visible = false;			}			else			{				_redDome.visible = false;				_greenDome.visible = true;			}		}	}}