package com.friendsofed.gameElements.spaceShip{	import flash.events.Event;	import flash.events.EventDispatcher;	public class ShipModel extends EventDispatcher	{		private var _previousX:Number = 0;		private var _previousY:Number = 0;		private var _xPos:Number = 0;		private var _yPos:Number = 0;		private var _temporaryX:Number = 0;		private var _temporaryY:Number = 0;		private var _rotationSpeed:Number = 0;		private var _accelerationX:Number = 0;		private var _accelerationY:Number = 0;		private var _frictionX:Number = 0;		private var _frictionY:Number = 0;		private var _acceleration:Number = 0;		private var _friction:Number = 0;		private var _frictionConstant:Number = 0.96; //Global friction		private var _angle:Number = 0;		private var _rotationValue:Number = 0;		private var _direction:Number = 0;		private var _height:uint = 30;		private var _width:uint;		private var _color:uint;		private var _thrusterFired:Boolean = false;		public function ShipModel(color:uint = 0x99FF66, 		                          width:uint = 30):void 		{		  this._width = width;		  this._color = color;		}		public function update():void		{			//Temporarily store the current x and y positions			_temporaryX = xPos;			_temporaryY = yPos;						//Calculate the rotationValue			_rotationValue += _rotationSpeed;						//Calculate the angle and acceleration			_angle = _rotationValue * (Math.PI / 180);			_accelerationX = Math.cos(_angle) * _acceleration;			_accelerationY = Math.sin(_angle) * _acceleration;						_frictionX = vx * _friction;			_frictionY = vy * _friction;						//Alternate friction equation			//_frictionX = (_xPos - _previousX) * _friction;			//_frictionY = (_yPos - _previousY) * _friction;						//Speed trap:Stop the object moving 			//if the up arrow isn't being pressed			//and its speed falls below 0.1						if(! _thrusterFired)			{			  if((Math.abs(vx) < 0.1) && (Math.abs(vy) < 0.1))			  {				  _accelerationX = 0;				  _accelerationY = 0;			  }		  }      			//Apply acceleration to the			//public xPos and yPos properties			xPos += _accelerationX + _frictionX;			yPos += _accelerationY + _frictionY;						//The temporary values becomes the      //previous positions, which are used calculate velocity			_previousX = temporaryX;			_previousY = temporaryY;		}		//Getters and setters		//width		public function get width():uint		{			return _width;		}				//width		public function get height():uint		{			return _height;		}				//width		public function get color():uint		{			return _color;		}    				//acceleration		public function get acceleration():Number		{			return _acceleration;		}		public function set acceleration(value:Number):void		{			_acceleration = value;		}				//friction		public function get friction():Number		{			return _friction;		}		public function set friction(value:Number):void		{			_friction = value;		}				//frictionConstant		public function get frictionConstant():Number		{			return _frictionConstant;		}		public function set frictionConstant(value:Number):void		{			_frictionConstant = value;		}				//rotationValue		public function get rotationValue():Number		{			return _rotationValue;		}		public function set rotationValue(value:Number):void		{			_rotationValue = value;dispatchEvent(new Event(Event.CHANGE));		}				//rotationSpeed		public function get rotationSpeed():Number		{			return _rotationSpeed;		}		public function set rotationSpeed(value:Number):void		{			_rotationSpeed = value;		}				//angle		public function get angle():Number		{			_angle = _rotationValue * (Math.PI / 180);			return _angle		}				//accelerationX		public function get accelerationX():Number		{			_accelerationX = Math.cos(_angle) * _acceleration;			return _accelerationX;		}				//accelerationY		public function get accelerationY():Number		{			_accelerationY = Math.sin(_angle) * _acceleration;			return _accelerationY;		}				//thrusterFired		public function get thrusterFired():Boolean		{			return _thrusterFired;		}		public function set thrusterFired(value:Boolean):void		{			_thrusterFired = value;			dispatchEvent(new Event(Event.CHANGE));		}				//temporaryX		public function get temporaryX():Number		{			return _temporaryX;		}		public function set temporaryX(value:Number):void		{			_temporaryX = value;		}				//temporaryY		public function get temporaryY():Number		{			return _temporaryY;		}		public function set temporaryY(value:Number):void		{			_temporaryY = value;		}				//previousX		public function get previousX():Number		{			return _previousX;		}		public function set previousX(value:Number):void  	{  		previousX = value;  	}				//previousY		public function get previousY():Number		{			return _previousY;		}		public function set previousY(value:Number):void    {    	previousY = value;    }				//vx		public function get vx():Number		{			return _xPos - _previousX;		}		public function set vx(value:Number):void		{			_previousX = _xPos - value;		}				//vy		public function get vy():Number		{			return _yPos - _previousY;		}		public function set vy(value:Number):void		{			_previousY = _yPos - value;		}				//xPos		public function get xPos():Number		{			return _xPos;		}		public function set xPos(value:Number):void		{			_xPos = value;			dispatchEvent(new Event(Event.CHANGE));		}				//yPos		public function get yPos():Number		{			return _yPos;		}		public function set yPos(value:Number):void		{			_yPos = value;			dispatchEvent(new Event(Event.CHANGE));		}				//setX		public function set setX(value:Number):void		{		  _previousX = value - vx;			xPos = value;		}				//setY		public function set setY(value:Number):void		{			_previousY = value - vy;			yPos = value;		}	}}