package com.friendsofed.vector{	import com.friendsofed.utils.*;	import flash.display.Sprite;	import flash.display.Shape;	import flash.events.Event;	public class VectorView extends Sprite	{		private var _v1:VectorModel;		private var _vx:Number;		private var _vy:Number;		private var _startX:Number;		private var _startY:Number;		private var _endx:Number;		private var _endy:Number;		private var _rx:Number;		private var _ry:Number;		private var _lx:Number;		private var _ly:Number;		private var _dx:Number;		private var _dy:Number;		private var _angle:Number;		private var _m:Number;		private var _renderMode:String;		private var _scaleAmount:Number;				//Each vector line is Shape object		private var _mainVector:Shape;		private var _rn:Shape;		private var _ln:Shape;		private var _mainVector_Vx:Shape;		private var _mainVector_Vy:Shape;				//Strings objects, which will contain the actual text displayed		private var _mainVector_Text:String;		private var _rn_Text:String;		private var _ln_Text:String;		private var _vx_Text:String;		private var _vy_Text:String;				//RotationText, which will contain the strings used to lablel the vectors		//RotationText is a custom class that creates and formats the vector label text		//It also includes an embedded font		private var _statusBox:StatusBox;		private var _rn_Label:RotationText;		private var _ln_Label:RotationText;		private var _vx_Label:RotationText;		private var _vy_Label:RotationText;				public function VectorView(vector:VectorModel, renderMode:String = "basic", scaleAmount:Number = 1):void 		{			//Find the status box display type type			switch (renderMode)			{				case "basic" :					this._renderMode = "basic";					break;							case "detailed" :					this._renderMode = "detailed";					break;										case "status" :    			this._renderMode = "status";    			_statusBox = new StatusBox();    			addChild(_statusBox);    			break;								default:					this._renderMode = "basic";			}						this._v1 = vector;			_v1.addEventListener(Event.CHANGE, onChange);						this._scaleAmount = scaleAmount;						addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}		private function onAddedToStage(event:Event):void		{			_mainVector = new Shape();			addChild(_mainVector);						if(_renderMode != "basic")			{				_mainVector_Vx = new Shape();				addChild(_mainVector_Vx);				_mainVector_Vy = new Shape();				addChild(_mainVector_Vy);				_rn = new Shape();				addChild(_rn);				_ln = new Shape();				addChild(_ln);							_rn_Label = new RotationText("rn", 12, 0x999999);				addChild(_rn_Label);				_ln_Label = new RotationText("ln", 12, 0x999999);				addChild(_ln_Label);				_vx_Label = new RotationText("vx", 12, 0x999999);				addChild(_vx_Label);				_vy_Label = new RotationText("vy", 12, 0x999999);				addChild(_vy_Label);			}						addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}		private function onRemovedFromStage(event:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}				//onChange  is called by the VectorModel's update method			  public function onChange(event:Event):void		{			//Find the new vector coordinates						_startX = _v1.a.x;			_startY = _v1.a.y;			_m = _v1.m;									//Sometimes you need a vector that's a different length			//but points in the same direction. Here's how			//to scale a vector:						if(_scaleAmount != 1)			{				//1. Scale the length								var newMagnitude:Number = _m * _scaleAmount;				_m = newMagnitude;								//2. Scale the vector by multiplying the normalized vector with the new length								_endx = _startX + (_v1.dx * _m);				_endy = _startY + (_v1.dy * _m);			}			else			{				_endx = _v1.b.x;				_endy = _v1.b.y;			}						_vx = _v1.vx;			_vy = _v1.vy;			_rx = _v1.rx;			_ry = _v1.ry;			_lx = _v1.lx;			_ly = _v1.ly;			_dx = _v1.dx;			_dy = _v1.dy;			_angle = _v1.angle;						//Plot the vector status box text						if(_renderMode == "status")			{			  				_statusBox.text = "START: " + Math.round(_startX) + ", " + Math.round(_startY);				_statusBox.text += "\n" + "END: " + Math.round(_endx) + ", " + Math.round(_endy);				_statusBox.text += "\n" + "VX = " + Math.round(_vx * 1000) / 1000;				_statusBox.text += "\n" + "VY = " + Math.round(_vy * 1000) / 1000;				_statusBox.text += "\n" + "MAGNITUDE = " + Math.round(_m * 1000) / 1000;				_statusBox.text += "\n" + "ANGLE = " + Math.round(_angle * 1000) / 1000;				_statusBox.text += "\n" + "RX = " + Math.round(_rx * 1000) / 1000;				_statusBox.text += "\n" + "RY = " + Math.round(_ry * 1000) / 1000;				_statusBox.text += "\n" + "LX = " + Math.round(_lx * 1000) / 1000;				_statusBox.text += "\n" + "LY = " + Math.round(_ly * 1000) / 1000;				_statusBox.text += "\n" + "RN.b = " + Math.round(_startX + _rx) + ", " +  Math.round(_startY + _ry);				_statusBox.text += "\n" + "LN.b = " + Math.round(_startX + _lx) + ", " + Math.round(_startY + _ly);								//Round the dx and dy values to two decimal places								_statusBox.text += "\n" + "DX:" + Math.round(_dx * 1000) / 1000;				_statusBox.text += "\n" + "DY:" + Math.round(_dy * 1000) / 1000;								/*				//Raw data (not rounded)				_statusBox.text = "START: " + _startX + ", " + _startY;  			_statusBox.text += "\n" + "END: " + _endx + ", " + _endy;  			_statusBox.text += "\n" + "VX = " + _vx;  			_statusBox.text += "\n" + "VY = " + _vy;  			_statusBox.text += "\n" + "MAGNITUDE = " + _m;  			_statusBox.text += "\n" + "ANGLE = " + _angle;  			_statusBox.text += "\n" + "RX = " + _rx;  			_statusBox.text += "\n" + "RY = " + _ry;  			_statusBox.text += "\n" + "LX = " + _lx;  			_statusBox.text += "\n" + "LY = " + _ly;  			_statusBox.text += "\n" + "RN.b = " + (_startX + _rx) + ", " +  (_startY + _ry);  			_statusBox.text += "\n" + "LN.b = " + (_startX + _lx) + ", " + (_startY + _ly);				_statusBox.text += "\n" + "DX:" + _dx;  			_statusBox.text += "\n" + "DY:" + _dy;  			*/  						}						//Draw the main vector						_mainVector.graphics.clear();			_mainVector.graphics.lineStyle(1, 0xFF0000, 1);			_mainVector.graphics.moveTo(_startX, _startY); 			_mainVector.graphics.lineTo(_endx, _endy);						if(_renderMode != "basic")			{				//Draw the x component								_mainVector_Vx.graphics.clear();				_mainVector_Vx.graphics.lineStyle(1, 0x999999, 1);				_mainVector_Vx.graphics.moveTo(_startX, _startY); 				_mainVector_Vx.graphics.lineTo(_endx, _startY);							//Draw the y component								_mainVector_Vy.graphics.clear();				_mainVector_Vy.graphics.lineStyle(1, 0x999999, 1);				_mainVector_Vy.graphics.moveTo(_endx, _startY); 				_mainVector_Vy.graphics.lineTo(_endx, _endy);							//Draw the right hand normal								_rn.graphics.clear();				_rn.graphics.lineStyle(1, 0x999999, 1);				_rn.graphics.moveTo(_startX, _startY); 				_rn.graphics.lineTo(_startX + _rx, _startY + _ry);							//Draw the left hand normal								_ln.graphics.clear();				_ln.graphics.lineStyle(1, 0x999999, 1);				_ln.graphics.moveTo(_startX, _startY); 				_ln.graphics.lineTo(_startX + _lx, _startY + _ly);							//Position the x component text								if(_vx > 10)				{					_vx_Label.x = _startX + _vx - _vx_Label.width;				}				else				{					_vx_Label.x = _startX + _vx;				}				_vx_Label.y = _startY;							//Position the y component text								_vy_Label.x = _startX + _vx;				if(_vy > 10)				{					_vy_Label.y = _startY + 10;					_vy_Label.rotation = 90;				}				else				{					_vy_Label.y = _startY - 10;					_vy_Label.rotation = 270;				}							//Make the x and y component text invisible if the vx and vy widths are less than 20								if((Math.abs(_vx) > 20) && (Math.abs(_vy) > 20))				{					_vx_Label.visible = true;					_vy_Label.visible = true;				}				else				{					_vx_Label.visible = false;					_vy_Label.visible = false;				}							//Make the vector normals text invisible is the length is less than 20								if(_m > 20)				{					_rn_Label.visible = true;					_ln_Label.visible = true;				}				else				{					_rn_Label.visible = false;					_ln_Label.visible = false;				}							//Position the right hand vector normal text								_rn_Label.x = _startX + (_rx);				_rn_Label.y = _startY + (_ry);								//Rotate the text								_rn_Label.rotation = _v1.rn.angle;							//Position the left hand vector normal text								_ln_Label.x = _startX + (_lx);				_ln_Label.y = _startY + (_ly);								//Rotate the text								_ln_Label.rotation = _v1.ln.angle;			}		}			//Public properties		public function set renderMode(renderMode:String):void		{			switch (_renderMode)			{				case "basic" :					this._renderMode = "basic";					break;								case "detailed" :					this._renderMode = "detailed";					break;									default:					this._renderMode = "basic";			}		}		public function get renderMode():String		{			return _renderMode;		}	}}