package com.friendsofed.vector{	import flash.geom.Point;	import flash.events.Event;	import flash.events.EventDispatcher;	public class VectorModel extends EventDispatcher	{	  //Start and end points for the main vector		private var _a:Point = new Point(0, 0);		private var _b:Point = new Point(0, 0);		private var _vx:Number = 0;		private var _vy:Number = 0;				public function VectorModel		  (		    startX:Number = 0, startY:Number = 0, 		    endx:Number = 0, endy:Number = 0,		    newVx:Number = 0, 		    newVy:Number = 0		  ):void		{		  update(startX, startY, endx, endy, newVx, newVy);		}		public function update		  (		    startX:Number = 0, 		    startY:Number = 0, 		    endx:Number = 0, 		    endy:Number = 0,		    newVx:Number = 0, 		    newVy:Number = 0		  ):void		{		  if(newVx == 0 && newVy == 0)		  {			  _a.x = startX			  _a.y = startY;			  _b.x = endx			  _b.y = endy;			  dispatchEvent(new Event(Event.CHANGE));		  }			else  		{  		  _vx = newVx;		    _vy = newVy;		    dispatchEvent(new Event(Event.CHANGE));  		}		}				//Start point		public function get a():Point		{			return _a;					}				//End point		public function get b():Point		{			return _b;		}				//vx		public function get vx():Number		{		  if(_vx == 0)		  {			  return _b.x - _a.x;		  }		  else		  {		    return _vx;		  }		}				//vy		public function get vy():Number		{		  if(_vy == 0)		  {			  return _b.y - _a.y;		  }		  else		  {		    return _vy;		  }		}				//angle (degrees)		public function get angle():Number		{			var angle_Radians:Number = Math.atan2(vy, vx);			var angle_Degrees:Number = angle_Radians * 180 / Math.PI;			return angle_Degrees;		}				//magnitude (length)		public function get m():Number		{		  if(vx != 0 || vy != 0)		  {			  var magnitude:Number = Math.sqrt(vx * vx + vy * vy);			  return magnitude;		  }		  else		  {		    return 0.001;		  }		}				//Left normal VectorModel object		public function get ln():VectorModel		{		  		  var leftNormal:VectorModel = new VectorModel();		  if(_vx == 0		  && _vy == 0)		  {		    leftNormal.update		      (		        a.x, a.y,             (a.x + this.lx),             (a.y + this.ly)          );		  }		  else		  {		    leftNormal.update(0, 0, 0, 0, vx, vy);		  }  		  		  return leftNormal;                 		}				//Right normal VectorModel object		public function get rn():VectorModel		{		  		  var rightNormal:VectorModel = new VectorModel();		 		  if(_vx == 0		  && _vy == 0)		  {		    rightNormal.update          (            a.x, a.y,             (a.x + this.rx),             (a.y + this.ry)          );		  }		  else		  {		    rightNormal.update(0, 0, 0, 0, vx, vy);		  }  		  return rightNormal;                 		}				//Right hand normal x component		public function get rx():Number		{			var rx:Number = -vy;			return rx		}				//Right hand normal y component		public function get ry():Number		{			var ry:Number = vx;			return ry;		}				//Left hand normal x component		public function get lx():Number		{			var lx:Number = vy;			return lx		}				//Left hand normal y component		public function get ly():Number		{			var ly:Number = -vx;			return ly;		}				//Normalized vector		//The code needs to make sure that		//the length value isn't zero to avoid		//returning NaN		public function get dx():Number		{		  if(m != 0)		  {			  var dx:Number = vx / m			  return dx;		  }		  else		  {		    return 0.001;		  }		}		public function get dy():Number		{		  if(m != 0)		  {			  var dy:Number = vy / m			  return dy;		  }		  else  		{  		  return 0.001;  		}  		}	}}