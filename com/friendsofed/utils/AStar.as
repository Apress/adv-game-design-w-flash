package com.friendsofed.utils{	public class AStar	{	  //An array to store the shortest path	  public var shortestPath:Array;	  //A 2D array of test nodes that matches the maze map	  public var nodeMap:Array;	  	  //The path's start and end nodes	  public var startNode_ID:uint = 0;	  public var destinationNode_ID:uint = 0;	  	  //How much it will cost to move between nodes?	  private var _straightCost:uint = 0;	  private var _diagonalCost:uint = 0;	  		public function AStar()		{		}				public function findShortestPath		  (		    startNode_ID:uint,	      destinationNode_ID:uint,	      map:Array,	      wall:uint,	      heuristic:String,	      straightCost:uint,	      diagonalCost:uint		  ):Array		{		   this.startNode_ID = startNode_ID;		   this.destinationNode_ID = destinationNode_ID;		   _straightCost = straightCost;		   _diagonalCost = diagonalCost;		  		  //Initialize the shortestPath array		  shortestPath = [];		  		  //Initialize the node map		  nodeMap = initializeNodeMap(map);		  		  //Initialize the closed and open list arrays  	  var closedList:Array = [];  	  var openList:Array = [];  	    	  //Get the current center node. The first one will  	  //be the startNode_ID, which is the player's start  	  //position.  	  var centerNode:Object   	    = nodeMap  	      [uint(startNode_ID % 100)]  	      [uint(startNode_ID / 100)];  	    	  //Get a reference to the destinationNode. It will  	  //match the destinationNode_ID  	  var destinationNode:Object   	    = nodeMap  	      [uint(destinationNode_ID % 100)]  	      [uint(destinationNode_ID / 100)];   	    	  //Loop until the destination node is found  	  while(centerNode.id != destinationNode_ID)  	  {  	    //Check all the 8 nodes surrounding the centerNode  	    for(var column:int = -1; column < 2; column++)        {          for(var row:int = -1; row < 2; row++)          {            //Find the row and column to test            var testRow:int = centerNode.row + row;            var testColumn:int = centerNode.column + column;                        //Make sure that the row and column being tested are            //valid array elements and aren't beyond the            //edges of the map            if(testRow > -1 && testRow <= nodeMap.length            && testColumn > -1 && testColumn <= nodeMap[0].length)            {              //If the test node isn't the centerNode              //and the mazeMap doesn't contain a wall tile...                            //This if statement cuts corners:               /*              if(nodeMap[testRow][testColumn].id                 != centerNode.id              && map[testRow][testColumn] != wall)              {              */                            //This if statement rounds corners:              if(nodeMap[testRow][testColumn].id                 != centerNode.id              && map[testRow][testColumn] != wall              && map[testRow][centerNode.column] != wall              && map[centerNode.row][testColumn] != wall)              {                              //Get a reference to the surrounding node                var testNode:Object = nodeMap[testRow][testColumn];                                //trace(testNode.id);                              //Find out whether the node is on a straight axis or                 //a diagonal axis, and assign the appropriate cost                              //A. Declare the cost variable                var cost:uint;                              //B. Do they occupy the same row or column?                if(centerNode.row == testNode.row                || centerNode.column == testNode.column)                {                  //... if they do, assign a cost of "10"                  cost = straightCost;                  //trace("straight");                }                else                {                  //otherwise, assign a cost of "14"                  cost = diagonalCost;                  //trace("diagonal");                }                              //C. Calculate the costs (g, h and f)                //The node's current cost                var g:uint = centerNode.g + cost;                              //The cost of travelling from this node to the                //destination node                var h:uint                switch(heuristic)                {                  case "manhattan":                    h = manhattan(testNode, destinationNode);                    break;                                    case "euclidean":                    h = euclidean(testNode, destinationNode);                    break;                                      case "diagonal":                    h = diagonal(testNode, destinationNode);                    break;                                      default:                    throw new Error                      ("Oops! You misspelled the heuristic");                }                             //The final cost                      var f:uint = g + h;                              //Find out if the testNode is on either on                //the openList or closedList arrays                var isOnOpenList:Boolean = false;                var isOnClosedList:Boolean = false;                              //Check the openList                for(var i:int = 0; i < openList.length; i++)                {                  if(testNode == openList[i])                  {                    isOnOpenList = true;                  }                }                              //Check the closedList                for(var j:int = 0; j < closedList.length; j++)                {                  if(testNode == closedList[j])                  {                    isOnClosedList = true;                  }                }                             //If it's on either of these lists, we can check                //whether this route is a lower-cost                 //alternative to the                //to the previous cost calculation. The new G cost                //will make the difference to the final F cost                if(isOnOpenList || isOnClosedList)                {                  if(testNode.f > f)                  {                    testNode.f = f;                    testNode.g = g;                    testNode.h = h;                                        //Only change the parent if the new cost is lower                    testNode.parent = centerNode;                  }                }                              //Otherwise, add the testNode to the open list                else                {                  testNode.f = f;                  testNode.g = g;                  testNode.h = h;                  testNode.parent = centerNode;                  openList.push(testNode);                }              }            }          }        }        //Push the current centerNode into the closed list        closedList.push(centerNode);                //Quit the loop if there's nothing on the open list        //This means that there is no path to the destination or the         //destination is invalid, like a wall tile.        if(openList.length == 0)        {          //trace("No path found");          return shortestPath;        }        //Sort the open list according to final cost        openList.sortOn("f", Array.NUMERIC);              //Set the node with the lowest final cost as the new        //centerNode        centerNode = openList.shift();  	  }  	    	  //Now that we have all the candidates, let's  	  //find the shortest path!  	  if(openList.length != 0)      {  	    //Start with the destination node    	  var node:Object = destinationNode;    	  shortestPath.push(node);  	      	  //Work backwards through the node parents    	  //until the start node is found    	  while(node.id != startNode_ID)    	  {    	    //Step through the parents of each node,    	    //starting with the destination node    	    //and ending with the start node    	    node = node.parent;  	        	    //Add the node to the beginning of the array    	    shortestPath.unshift(node);  	        	    //...and then loop again to the next node's parent till you     	    //reach the end of the path    	  }  	    /*    	  trace("Shortest path:");    	  for(var k:int = 0; k < shortestPath.length; k++)        {          trace(shortestPath[k].id);        }        */      }      return shortestPath;		}		private function initializeNodeMap(map:Array):Array  	{  	  //A blank array to store the nodes  	  var nodeMap:Array = [];  	    	  for(var row:int = 0; row < map.length; row++)      {        nodeMap[row] = new Array();                for(var column:int = 0; column < map[0].length; column++)        {          //Create the node object and intialize the          //values it will need to track          var node:Object = new Object();          node.f = 0;          node.g = 0;          node.h = 0;          node.parent = null;                    //Assign the row and column          node.row = row;          node.column = column;                    //Assign the node's unique ID number          node.id = (column * 100) + row;                    //Add the node object to this cell          nodeMap[row][column] = node;        }      }            //Return the nodeMap array      return nodeMap;	  }		//Heuristic methods	  //1. Manhattan	  private function manhattan	    (testNode:Object, destinationNode:Object):uint  	{  	  var h:uint         = Math.abs          (testNode.row - destinationNode.row) * _straightCost         + Math.abs          (testNode.column - destinationNode.column) * _straightCost;                return h;	  }	  //2. Euclidean	  private function euclidean	    (testNode:Object, destinationNode:Object):uint  	{  	  var vx:int = destinationNode.column - testNode.column;  	  var vy:int = destinationNode.row - testNode.row;  	  var h:uint = uint(Math.sqrt(vx * vx + vy * vy) * _straightCost);                return h;	  }	  	  private function diagonal	    (testNode:Object, destinationNode:Object):uint  	{  	  var vx:uint   	    = Math.abs(destinationNode.column - testNode.column);  	  var vy:uint   	    = Math.abs(destinationNode.row - testNode.row);  	    	  var h:uint;      	  if(vx > vy)  	  {  	    h = uint(_diagonalCost * vy + _straightCost * (vx - vy));  	  }  	  else  	  {  	     h = uint(_diagonalCost * vx + _straightCost * (vy - vx));  	  }                return h;    }	}}