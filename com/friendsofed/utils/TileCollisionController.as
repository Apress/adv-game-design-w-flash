package com.friendsofed.utils{  import com.friendsofed.vector.*;  import com.friendsofed.gameElements.primitives.*;  	public class TileCollisionController	{	  private var _softPlatformOpen:Boolean = true;	  private var _elevatorOpen:Boolean = true;	  		public function TileCollisionController()		{		}				public function platformCollision		  (		    gameObject:TileModel, 		    platformMap:Array, 		    maxTileSize:uint,		    platform:uint		  ):void		{       //Variables needed to figure out by how much the object      //is overlapping the tile on the x and y axis      //The axis with the most overlap is the axis on which      //the collision is occurring. This is an inverted SAT system      var overlapX:Number;      var overlapY:Number;             //If the object's top left corner is overlapping the tile      //on its upper left side...      if(platformMap[gameObject.top][gameObject.left] == platform)      {        //Figure out by how much the object's top left corner        //point is overlapping the tile on both the x and y        //axes.         overlapX = gameObject.xPos % maxTileSize;        overlapY = gameObject.yPos % maxTileSize;                if(overlapY >= overlapX)        {          if(gameObject.vy < 0          && platformMap[gameObject.bottom][gameObject.left]           != platform)          {            //Collision on top side of the object            //Position the object to the bottom             //edge of the platform tile            //which it is overlapping and set its vy to zero            gameObject.setY = (gameObject.mapRow * maxTileSize);    		    gameObject.vy = 0;		      }          }        else        {          //Collision on left side of the object          //Position the object to the right           //edge of the platform tile and set its vx to zero          gameObject.setX             = gameObject.mapColumn * maxTileSize;		      gameObject.vx = 0;        }      }            //If the object's bottom left corner is overlapping the tile      //on its lower left side...      if(platformMap[gameObject.bottom][gameObject.left] == platform)      {        overlapX = gameObject.xPos % maxTileSize;                //Measure the y overlap from far left side of the tile        //and compensate for the object's height        overlapY           = maxTileSize           - ((gameObject.yPos + gameObject.height) % maxTileSize);               if(overlapY >= overlapX)        {          if(gameObject.vy > 0          && platformMap[gameObject.top][gameObject.left]           != platform)          {            //Collision on bottom            gameObject.setY              = (gameObject.mapRow * maxTileSize)              + (maxTileSize - gameObject.height);  		      gameObject.vy = 0;    		    gameObject.jumping = false;		      }        }        else        {          //Collision on left          gameObject.setX             = gameObject.mapColumn * maxTileSize;		      gameObject.vx = 0;        }      }            //If the object's bottom right corner is overlapping the tile      //on its lower right side...      if(platformMap[gameObject.bottom][gameObject.right]         == platform)      {        //Measure the x and y overlap from the far right and bottom        //side of the tile and compensate for the object's        //height and width        overlapX           = maxTileSize           - ((gameObject.xPos + gameObject.width) % maxTileSize);        overlapY           = maxTileSize           - ((gameObject.yPos + gameObject.height) % maxTileSize);                if(overlapY >= overlapX)        {          if(gameObject.vy > 0          && platformMap[gameObject.top][gameObject.right]           != platform)          {            //Collision on bottom            gameObject.setY               = (gameObject.mapRow * maxTileSize)              + (maxTileSize - gameObject.height);  		      gameObject.vy = 0;    		    gameObject.jumping = false;		      }        }        else        {          //Collision on right          gameObject.setX             = (gameObject.mapColumn * maxTileSize)            + ((maxTileSize - gameObject.width) - 1);		      gameObject.vx = 0;        }      }      //If the object's top right corner is overlapping the tile      //on its upper right side...      if(platformMap[gameObject.top][gameObject.right]         == platform)      {         //Measure the x overlap from the far right side of the        //tile and compensate for the object's width        overlapX           = maxTileSize           - ((gameObject.xPos + gameObject.width) % maxTileSize);        overlapY = gameObject.yPos % maxTileSize;                if(overlapY >= overlapX)        {          if(gameObject.vy < 0          && platformMap[gameObject.bottom][gameObject.right]           != platform)          {            gameObject.setY = (gameObject.mapRow * maxTileSize);    		    gameObject.vy = 0;		      }        }        else        {          //Collision on right          gameObject.setX             = (gameObject.mapColumn * maxTileSize)            + ((maxTileSize - gameObject.width) - 1);		      gameObject.vx = 0;        }      }		} 		public function starCollision		  (		    gameObject:TileModel,		    starTileObject:TileModel, 		    platformMap:Array, 		    maxTileSize:uint,		    star:uint		  ):Boolean		{       var collision:Boolean = false;            //Make sure that the code doesn't check for rows that      //are greater than the number of rows and columns on the map      if(gameObject.bottom < platformMap.length      && gameObject.right < platformMap[0].length)      {        //If the object's corners are overlapping a tile        //that contains a star...        if(platformMap[gameObject.top][gameObject.left] == star        || platformMap[gameObject.top][gameObject.right] == star        || platformMap[gameObject.bottom][gameObject.left]  == star        || platformMap[gameObject.bottom][gameObject.right] == star)        {          //Plot a vector between the gameObject's           //center point and the star          var v0:VectorModel 			      = new VectorModel    			  (    			    gameObject.xPos + (gameObject.width * 0.5),     			    gameObject.yPos + (gameObject.height * 0.5),     			    starTileObject.xPos + (starTileObject.width * 0.5),     			    starTileObject.yPos + (starTileObject.height * 0.5)    			  );                               			    			//Calculate the the combined widths of the objects    			var totalRadii:Number     			  = gameObject.width * 0.5     			  + starTileObject.width * 0.5;                             			    			if(v0.m < totalRadii)    			{    			  //There's a collision if the distance between the objects    			  //is less than their combined widths    			  collision = true;  			  }        }      }      //Return the true or false value of "collision"      //back to the application class      return collision;		} 		public function roundPlatformCollision		  (		    gameObject:TileModel, 		    platformMap:Array, 		    maxTileSize:uint,		    roundTile:uint		  ):void		{       var roundTile_X:uint;      var roundTile_Y:uint;      var tileRadius:uint;            //Make sure that the code doesn't check for rows that      //are greater than the number of rows and columns on the map      if(gameObject.bottom < platformMap.length      && gameObject.right < platformMap[0].length)      {        //If the object's top left corner is overlapping the tile        //on its upper left side...        if(platformMap[gameObject.top][gameObject.left]         == roundTile)        {          roundTile_X = gameObject.left * maxTileSize;          roundTile_Y = gameObject.top * maxTileSize;          tileRadius = maxTileSize * 0.5;          roundTileCollision            (gameObject, roundTile_X, roundTile_Y, tileRadius);        }              //If the object's top right corner is overlapping the tile        //on its upper right side...        if(platformMap[gameObject.top][gameObject.right]         == roundTile)        {          roundTile_X = gameObject.right * maxTileSize;          roundTile_Y = gameObject.top * maxTileSize;          tileRadius = maxTileSize * 0.5;          roundTileCollision            (gameObject, roundTile_X, roundTile_Y, tileRadius);        }        //If the object's bottom left corner is overlapping the tile        //on its lower left side...        if(platformMap[gameObject.bottom][gameObject.left]         == roundTile)        {          roundTile_X = gameObject.left * maxTileSize;          roundTile_Y = gameObject.bottom * maxTileSize;          tileRadius = maxTileSize * 0.5;          roundTileCollision            (gameObject, roundTile_X, roundTile_Y, tileRadius);        }        //If the object's bottom right corner is overlapping the tile        //on its lower right side...        if(platformMap[gameObject.bottom][gameObject.right]         == roundTile)        {          roundTile_X = gameObject.right * maxTileSize;          roundTile_Y = gameObject.bottom * maxTileSize;          tileRadius = maxTileSize * 0.5;          roundTileCollision            (gameObject, roundTile_X, roundTile_Y, tileRadius);        }      }		} 		//roundTile collisions		public function roundTileCollision		  (		    gameObject:TileModel, 		    roundTile_X:uint, 		    roundTile_Y:uint,		    tileRadius:uint		  ):void		{		  		  //Vector between circles		  //Measure from the center points			var v0:VectorModel 			  = new VectorModel			  (			    gameObject.xPos + (gameObject.width * 0.5), 			    gameObject.yPos + (gameObject.height * 0.5), 			    roundTile_X + tileRadius, 			    roundTile_Y + tileRadius			  );                               						//Calculate the radii of both circles combined			var totalRadii:Number = (gameObject.width * 0.5) + tileRadius;                             						if(v0.m < totalRadii)			{			  //A collision is happening			  //Find the amount of overlap between circles				var overlap:Number = totalRadii - v0.m;                      			  gameObject.setX = gameObject.xPos - (overlap * v0.dx);				gameObject.setY = gameObject.yPos - (overlap * v0.dy);				        //_c1's motion vector  			var v1:VectorModel   			  = new VectorModel  			  (  			    gameObject.xPos, gameObject.yPos,   			    gameObject.xPos + gameObject.vx,   			    gameObject.yPos + gameObject.vy  			  );  			                                             //Create c1's bounce vector                          var bounce_C1:VectorModel = VectorMath.bounce(v1, v0.ln);                //Bounce c1        gameObject.vx = bounce_C1.vx;         gameObject.vy = bounce_C1.vy;			}	    else	    {	      //No collision	    }	  }						public function softPlatformCollision		  (		    gameObject:TileModel, 		    platformMap:Array, 		    maxTileSize:uint,		    softPlatform:uint		  ):void		{ 		  //Check whether the object is moving down      if(gameObject.vy > 0)      {         //If the object's bottom left corner is overlapping the         //soft platform tile        //on its lower left side or right side...        if(platformMap[gameObject.bottom][gameObject.left]           == softPlatform        || platformMap[gameObject.bottom][gameObject.right]           == softPlatform)        {          //Find out which tile the bottom of the object          //was in on the previous frame          var previousTile:uint             = uint((gameObject.previousY             + gameObject.height) / maxTileSize);                    //Compare the current tile to the previous tile.          //If they're not the same, then you know that the          //object has crossed above the top of the tile          if(gameObject.bottom != previousTile          || !_softPlatformOpen)          {            //Collision on bottom            gameObject.setY              = (gameObject.mapRow * maxTileSize)              + (maxTileSize - gameObject.height);    	      gameObject.vy = 0;    		    gameObject.jumping = false;    		        		    //Close the platform so that the object    		    //can't fall through    		    _softPlatformOpen = false;		      }        }  		}  		//Open the platform if the object is  		//moving upwards again  		if(gameObject.vy < 0)  		{  		  _softPlatformOpen = true;  		} 	  }	  	  //Circle collisions		public function circleCollision		  (gameObject:TileModel, platform:TileModel):void		{		  var c1:TileModel = gameObject;		  var c2:TileModel = platform;		  var c1_Radius:Number = gameObject.width * 0.5;		  var c2_Radius:Number = platform.width * 0.5;		  		  //Vector between circles		  //Measure from the center points			var v0:VectorModel 			  = new VectorModel			  (			    c1.xPos + c1_Radius, 			    c1.yPos + c1_Radius, 			    c2.xPos + c2_Radius, 			    c2.yPos + c2_Radius			  );                               						//Calculate the radii of both circles combined			var totalRadii:Number = c1_Radius + c2_Radius;                             						if(v0.m < totalRadii)			{			  //A collision is happening			  //Find the amount of overlap between circles				var overlap:Number = totalRadii - v0.m;                      			  c1.setX = c1.xPos - (overlap * v0.dx);				c1.setY = c1.yPos - (overlap * v0.dy);				        //_c1's motion vector  			var v1:VectorModel   			  = new VectorModel  			  (  			    c1.xPos, c1.yPos,   			    c1.xPos + c1.vx,   			    c1.yPos + c1.vy  			  );  			                                             //Create c1's bounce vector                          var bounce_C1:VectorModel = VectorMath.bounce(v1, v0.ln);                //Bounce c1        c1.vx = bounce_C1.vx;         c1.vy = bounce_C1.vy;			}	    else	    {	      //No collision	    }	  }	  	  //Enemy collisions		public function enemyCollision		  (gameObject:TileModel, enemy:TileModel):Boolean		{		  var gameObject_Radius:Number = gameObject.width * 0.5;		  var enemy_Radius:Number = enemy.width * 0.5;		  var enemySquashed:Boolean = false;		  		  //Vector between circles		  //Measure from the center points			var v0:VectorModel 			  = new VectorModel			  (			    gameObject.xPos + gameObject_Radius, 			    gameObject.yPos + gameObject_Radius, 			    enemy.xPos + enemy_Radius, 			    enemy.yPos + enemy_Radius			  );                               						//Calculate the radii of both circles combined			var totalRadii:Number = gameObject_Radius + enemy_Radius;                             						//If the total radius is less than the distance			//between the objects and the gameObject is above the			//enemy			if(v0.m < totalRadii			&& gameObject.yPos + enemy_Radius < enemy.yPos)			{			  //A collision is happening			  //Find the amount of overlap between circles				var overlap:Number = totalRadii - v0.m;                      			  gameObject.setX = gameObject.xPos - (overlap * v0.dx);				gameObject.setY = gameObject.yPos - (overlap * v0.dy);				        //The cat's motion vector  			var v1:VectorModel   			  = new VectorModel  			  (  			    gameObject.xPos, gameObject.yPos,   			    gameObject.xPos + gameObject.vx,   			    gameObject.yPos + gameObject.vy  			  );  			                                             //Create c1's bounce vector                          var bounce_Player:VectorModel = VectorMath.bounce(v1, v0.ln);                //Bounce c1        gameObject.vx = bounce_Player.vx;         gameObject.vy = bounce_Player.vy;                enemySquashed = true;			}	    else	    {	      //No collision	    }	    	    return enemySquashed;	  }		//Collision between a gameObject character and platforms		//using the Seperating Axis Theorum		public function elevatorCollision		  (gameObject:TileModel, elevator:TileModel):void		{		  var v0:VectorModel 		    = new VectorModel		    (		      gameObject.xPos + gameObject.width * 0.5, 			    gameObject.yPos + gameObject.height * 0.5, 			    elevator.xPos + elevator.width * 0.5, 			    elevator.yPos + elevator.height * 0.5		    )						if(Math.abs(v0.vy) < gameObject.height * 0.5			    + elevator.height * 0.5)			  {			    //A collision has ocurred! This is good!			    //Find out the size of the overlap on both the X and Y axes			    var overlap_X:Number 			      = gameObject.width * 0.5 			      + elevator.width * 0.5 - Math.abs(v0.vx);			    var overlap_Y:Number 			      = gameObject.height * 0.5 			      + elevator.height * 0.5 - Math.abs(v0.vy);			    			    //The collision has occurred on the axis with the			    //*smallest* amount of overlap. Let's figure out which			    //axis that is			    			    if(overlap_X >=  overlap_Y)			    {			      //The collision is happening on the x axis			      //But on which side? (top or bottom?) 			      //v0's vy can tell us 			      if(v0.vy > 0)			      {			        //Collision on top			        //Check whether the gameObject is completely			        //above the platform.			        //"-2" is added to provide a bit of			        //tolerance that might be needed if the			        //downward velocites of the gameObject and			        //platform are very similar.			        			        if			          (			            gameObject.previousY - 2		                < elevator.yPos - gameObject.height		              || !_elevatorOpen		              || gameObject.vy == 0 && elevator.vy < 0		            )		          {			        //Move the gameObject out of the collision		          gameObject.setY = elevator.yPos - gameObject.height;		          		          //Set the gameObject's vy to the elevator's vy			        gameObject.vy = elevator.vy;			        gameObject.jumping = false;			        			        //Close the platform so that the object  		        //can't fall through  		        _elevatorOpen = false;		        }		      }                 		    }		  }		  else		  {		    //No collision		  }			//Open the elevator if the object is  		//moving upwards again and its velocity  		//isn't exactly the same as the elevator's  		if(gameObject.vy < 0  		&& gameObject.vy != elevator.vy)  		{  		  _elevatorOpen = true;  		} 		}				public function movingCircleCollision		  (c1:TileModel, c2:TileModel):void		{		  var c1_Radius:Number = c1.width * 0.5;		  var c2_Radius:Number = c2.width * 0.5;		        //Vector between the center of the circles			var v0:VectorModel 			  = new VectorModel			  (			    c1.xPos + c1_Radius, 			    c1.yPos + c1_Radius, 			    c2.xPos + c2_Radius, 			    c2.yPos + c2_Radius			  );       			var totalRadii:Number = c1_Radius + c2_Radius;  						if(v0.m < totalRadii)			{ 			 //trace("Collision")			  var overlap:Number = totalRadii - v0.m;			  			  var collision_Vx:Number = Math.abs(v0.dx * overlap * 0.5);        var collision_Vy:Number = Math.abs(v0.dy * overlap * 0.5);								var xSide:int;				var ySide:int;								c1.xPos + c1_Radius 				  > c2.xPos + c2_Radius 				  ? xSide = 1 : xSide = -1;				c1.yPos + c1_Radius				  > c2.yPos + c2_Radius 				  ? ySide = 1 : ySide = -1;								//Reposition _c1 out of the collision					c1.setX = c1.xPos + (collision_Vx * xSide);        c1.setY = c1.yPos + (collision_Vy * ySide);                //Reposition _c2 using _c1's original position before it        //was repositioned in the two lines of code above        c2.setX = c2.xPos + (collision_Vx * -xSide);        c2.setY = c2.yPos + (collision_Vy * -ySide);                //c1's motion vector  		  var v1:VectorModel = new VectorModel(c1.xPos, c1.yPos,   		                                       c1.xPos + c1.vx,   		                                       c1.yPos + c1.vy);  			                                       	  	//c2's motion vector        var v2:VectorModel = new VectorModel(c2.xPos, c2.yPos,                                              c2.xPos + c2.vx,                                              c2.yPos + c2.vy);                                                                                         var p1a:VectorModel = VectorMath.project(v1, v0);        var p1b:VectorModel = VectorMath.project(v1, v0.ln);                      //Project v2 onto v0 and vo.ln        var p2a:VectorModel = VectorMath.project(v2, v0);        var p2b:VectorModel = VectorMath.project(v2, v0.ln);                   //Bounce c1        //Combine p1b and p2a        c1.vx = p1b.vx + p2a.vx;         c1.vy = p1b.vy + p2a.vy;                 //Bounce c2        //Combine p1a and p2b        c2.vx = p1a.vx + p2b.vx;        c2.vy = p1a.vy + p2b.vy;      }		}	}}