package{	import flash.events.Event;	import flash.events.MouseEvent;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="832", height="768",   backgroundColor="#FFFFFF", frameRate="60")]  	public class MonsterMaze extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 13;	  private const MAP_ROWS:uint = 12;	  	  //tile ID numbers in tile sheet	  private const WALL:uint = 00;	  private const FLOOR:uint = 10;	  private const FAIRY:uint = 01;	  private const MONSTER:uint = 11;	 	  private var _mazeMap:Array	    = [	        [00,00,00,00,00,00,00,00,00,00,00,00,00],	        [00,10,10,10,10,10,10,10,10,00,00,10,00],	        [00,10,00,10,00,00,10,00,10,10,10,10,00],	        [00,10,00,10,10,10,10,10,00,00,10,00,00],	        [00,10,10,10,00,10,00,10,10,10,10,10,00],	        [00,10,00,10,00,10,00,10,00,10,00,10,00],	        [00,10,10,10,00,10,00,00,00,10,00,10,00],	        [00,10,00,00,00,10,10,10,10,10,00,10,00],	        [00,10,10,10,10,10,00,00,10,00,10,10,00],	        [00,10,00,10,00,10,10,00,10,10,10,00,00],	        [00,10,10,10,00,00,10,10,10,00,10,10,00],	        [00,00,00,00,00,00,00,00,00,00,00,00,00]	      ];    	   	   private var _gameObjectMap:Array	    = [	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,01,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]	      ];	        	  //Create blank BitmapData objects as the canvas for the game    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);    private var _foregroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _foregroundBitmap:Bitmap       = new Bitmap(_foregroundBitmapData);  	  	//Tile sheet		[Embed(source="../../images/mazeTileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Create a TileModel to represent the fairy    private var _fairyModel:TileModel;    private var _UIMazeController:UIMazeController;    private var _UIMazeView:UIMazeView         //Create a TileModel to represent the monster    private var _monsterModel:TileModel;        //Create a new AStar object    private var aStar:AStar = new AStar();        //Status box  	private var _statusBox:StatusBox = new StatusBox;				public function MonsterMaze():void		{  		  //Draw the tile sheet			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the game bitmaps			addChild(_backgroundBitmap);			addChild(_foregroundBitmap);						//Add the status box			addChild(_statusBox);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_mazeMap);			buildMap(_gameObjectMap);						stage.addEventListener			  (MouseEvent.MOUSE_DOWN, mouseDownHandler);			addEventListener			  (Event.ENTER_FRAME, enterFrameHandler);		}			private function mouseDownHandler(event:MouseEvent):void  	{  	  //Find the startNode  	  var playerColumn:uint = uint(_fairyModel.xPos / MAX_TILE_SIZE);  	  var playerRow:uint = uint(_fairyModel.yPos / MAX_TILE_SIZE);  	  var startNode_ID:uint = (playerColumn * 100) + playerRow;  	    	  //Find the destinationNode  		var mouseColumn:uint = uint(stage.mouseX / MAX_TILE_SIZE);  		var mouseRow:uint = uint(stage.mouseY / MAX_TILE_SIZE);  		var destinationNode_ID:uint  = (mouseColumn * 100) + mouseRow;  		  		var shortestPath:Array   		  = aStar.findShortestPath  		    (  		      startNode_ID,  		      destinationNode_ID,  		      _mazeMap,  		      WALL,  		      "manhattan",  		      10, 14  		    );  	}		private function enterFrameHandler(event:Event):void		{ 		  //1. UPDATE THE MODELS		  		  _fairyModel.update();		  _monsterModel.update();		  		  //2. CHECK FOR COLLISIONS		  		  //Check whether the monster is at the corner of		  //a tile and at an intersection		  if(atCornerOfTile(_monsterModel)		  && atIntersection(_monsterModel))		  {		    checkLineOfSight(_monsterModel, _fairyModel);	    }		  		  //A* Path walking		  if(atCornerOfTile(_fairyModel)		  && aStar.shortestPath != null)		  {		    if(aStar.shortestPath.length != 0)		    {		      //Next row and column in the path  		    var nextColumn:uint = uint(aStar.shortestPath[0].id / 100);  		    var nextRow:uint = uint(aStar.shortestPath[0].id % 100);  		      		    //If the _fairyModel is on the start node,  		    //use the next node in the array and remove the  		    //first one  		    if(_fairyModel.mapColumn == nextColumn  		    && _fairyModel.mapRow == nextRow)  		    {  		      nextColumn = uint(aStar.shortestPath[1].id / 100);  		      nextRow= uint(aStar.shortestPath[1].id % 100);  		      aStar.shortestPath.shift();  		    }		      		    if(_fairyModel.mapColumn != nextColumn)  		    {  		      if(_fairyModel.mapColumn > nextColumn)    		    {    		      //Move left    		      _fairyModel.vx = -8;      		    _fairyModel.vy = 0;    		    }    		    else    		    {    		      //Move right    		      _fairyModel.vx = 8;      		    _fairyModel.vy = 0;    		    }  	      }  	      else if(_fairyModel.mapRow != nextRow)  	      {  	        if(_fairyModel.mapRow > nextRow)    		    {    		      //Move up    		      _fairyModel.vx = 0;  		        _fairyModel.vy = -8;    		    }    		    else    		    {    		      //Move down    		      _fairyModel.vx = 0;  		        _fairyModel.vy = 8;    		    }  	      }  	      aStar.shortestPath.shift();        }        else        {           _fairyModel.vx = 0;  		     _fairyModel.vy = 0;        }      }      		  //3. BLIT THE OBJECTS		  		  //Clear the foreground		  _foregroundBitmapData.fillRect(_foregroundBitmapData.rect, 0);      		  //Blit the game objects		  drawGameObject(_fairyModel, _foregroundBitmapData);		  drawGameObject(_monsterModel, _foregroundBitmapData);		  		  //Update status box			_statusBox.text = "MONSTER MAZE:"; 	  }	  	  public function checkLineOfSight		  (		    chasingObject:TileModel, 		    targetObject:TileModel		  ):void		{		  //A variable to help track if any obstructing walls are found		  var wallFound:Boolean = false;		  		  //While loop counter variable		  var counter:uint;		  		  //A variable to help determine whether the direction is		  //left, right, up or down		  var direction:int = 1;		  		  //Check wether the objects are on the same row		  //but not in the same column		  if(chasingObject.mapRow == targetObject.mapRow		  && chasingObject.mapColumn != targetObject.mapColumn)		  {		    //If they are, find out whether the targetObject is		    //to the left or right of the chasingObject		    var vx:Number = targetObject.xPos - chasingObject.xPos;		    		    //Set the direction variable to "-1" if the targetObject		    //is to the left, or set it to "1" if it's to the right		    if(vx < 0)		    {		      direction = -1;	      }	      else	      {	        direction = 1;	      }	      	      //The counter is intialized to the number of tiles	      //between the chasingObject and the targetObject		    counter = uint(Math.abs(vx) / MAX_TILE_SIZE);		    //trace("Number of tiles, row: " + counter);	      while(counter-- != 0)	      {	        //Multiply the counter by the direction value to	        //find the correct number of cells to the left or right	        if            (  	          _mazeMap  	            [chasingObject.mapRow]  	            [chasingObject.mapColumn + (counter * direction)]            	    == WALL            )          {            //trace("wall found, row");            wallFound = true;            break;          }        }		    		    //Find a new random direction if a wall is found,		    //otherwise follow the targetObject		    if(wallFound)	      {	        findNewDirection(chasingObject);	      }	      else	      {	        if(direction == -1)	        {	          //trace("left");	          chasingObject.direction = "left";      		  chasingObject.vx = -8;      		  chasingObject.vy = 0;      		}      		else      		{      		  //trace("right");      		  chasingObject.direction = "right";      		  chasingObject.vx = 8;      		  chasingObject.vy = 0;      		}		    } 		  }		  		  if(chasingObject.mapColumn == targetObject.mapColumn		  && chasingObject.mapRow != targetObject.mapRow)		  {		    var vy:Number = targetObject.yPos - chasingObject.yPos;		  		    //Set the direction	      if(vy < 0)		    {		      direction = -1;	      }	      else	      {	        direction = 1;	      }	      	      //Check for walls	      counter = uint(Math.abs(vy) / MAX_TILE_SIZE);	      //trace("Number of tiles, column: " + counter);        while(counter-- != 0)        {          if            (	            _mazeMap	              [chasingObject.mapRow + (counter * direction)]	              [chasingObject.mapColumn]             	  == WALL            )          {            //trace("wall found, column");            wallFound = true;            break;          }        }                //Find a new random direction if a wall is found,		    //otherwise follow the targetObject	      if(wallFound)        {          findNewDirection(chasingObject);        }        else        {          if(direction == -1)          {            //trace("up");            chasingObject.direction = "up";  		      chasingObject.vx = 0;  		      chasingObject.vy = -8;		      }		      else		      {		        //trace("down");		        chasingObject.direction = "down";  		      chasingObject.vx = 0;  		      chasingObject.vy = 8;		      }        }		  }		  		  //If the objects are in completely different row and columns,		  //or they occupy exactly the same tile cell, the chasingObject		  //should find a new random direction		  if		    (		      (chasingObject.mapColumn != targetObject.mapColumn		        && chasingObject.mapRow != targetObject.mapRow)		      ||(chasingObject.mapColumn == targetObject.mapColumn		        && chasingObject.mapRow == targetObject.mapRow)		    )		  {		    findNewDirection(chasingObject);	    }	  }        public function findNewDirection(gameObject:TileModel):void		{		  var newDirection:String = "";		  //A random number between 1 and 4		  var randomDirection:int = Math.ceil(Math.random() * 4);	    	    //2. Encourage the monster to choose up or down if	    //it's currently moving left or right	    if(gameObject.direction == "left"	    || gameObject.direction == "right")	    {	      if(randomDirection <= 2)		    {	        newDirection = "up";		    }		    else		    {		      newDirection = "down";		    }       }      //...if the monster is currently moving up or down, make      //it move left or right      else      {        if(randomDirection <= 2)		    {	        newDirection = "left";		    }		    else		    {		      newDirection = "right";		    }       }            //Test the new direction and call this method recursively      //if the direction runs the object into a wall            switch(newDirection)      {        case "left":          if(_mazeMap[gameObject.mapRow][gameObject.mapColumn - 1]         		== FLOOR)        	{        	  gameObject.direction = newDirection;      		  gameObject.vx = -8;      		  gameObject.vy = 0;      		}      		else       		{      		  //If the test hits a wall, assign this direction as      		  //the object's new direction and test again.      		  //(Assigning the new direction prevents the objects      		  //from accidentally getting stuck in cul-de-sacs)      		  gameObject.direction = newDirection;      		  findNewDirection(gameObject);      		}      		break;      	      	case "right":	      	  if(_mazeMap[gameObject.mapRow][gameObject.mapColumn + 1]       		  == FLOOR)      		{      		  gameObject.direction = newDirection;    		    gameObject.vx = 8;    		    gameObject.vy = 0;    		  }    		  else     		  {    		    gameObject.direction = newDirection;      		  findNewDirection(gameObject);      		}      		break;      	      	case "up":	      	  if(_mazeMap[gameObject.mapRow - 1][gameObject.mapColumn]       		  == FLOOR)      		{      		  gameObject.direction = newDirection;    		    gameObject.vx = 0;    		    gameObject.vy = -8;    		  }    		  else    		  {    		    gameObject.direction = newDirection;      		  findNewDirection(gameObject);      		}	      		break;      	      	case "down":      	  if(_mazeMap[gameObject.mapRow + 1][gameObject.mapColumn]       		  == FLOOR)      		{      		  gameObject.direction = newDirection;    		    gameObject.vx = 0;    		    gameObject.vy = 8;    		  }    		  else      		{      		  gameObject.direction = newDirection;      		  findNewDirection(gameObject);      		}      		break;		      }	  }	  //Find out wether a game object is at an intersection		public function atIntersection(gameObject:TileModel):Boolean		{		  var horizontalPassage:Boolean = false;		  var verticalPassage:Boolean = false;		  var objectIsAtIntersection:Boolean = false;		  		  //An intersection is defined in this game as a place		  //where there is at least one horzontal and one		  //vertical passage open		  if(_mazeMap[gameObject.mapRow][gameObject.mapColumn + 1]     		  == FLOOR    	|| _mazeMap[gameObject.mapRow][gameObject.mapColumn - 1]     		  == FLOOR)    	{    	  horizontalPassage = true;    	}    	if(_mazeMap[gameObject.mapRow + 1][gameObject.mapColumn]     		  == FLOOR    	|| _mazeMap[gameObject.mapRow - 1][gameObject.mapColumn]     		  == FLOOR)    	{    	  verticalPassage = true;    	}    	    	//If a veritical and horizontal passage is open,    	//we've found an intersection    	if(horizontalPassage && verticalPassage)    	{    	  objectIsAtIntersection = true;    	}    	    	//Check whether the object is in a    	//dead end (wall on 3 sides)    	var wallCounter:uint = 0;    	if(_mazeMap[gameObject.mapRow][gameObject.mapColumn + 1]     		  == WALL)    	{    	  wallCounter++;    	}    	if(_mazeMap[gameObject.mapRow][gameObject.mapColumn - 1]     		  == WALL)    	{    	  wallCounter++;    	}	    	if(_mazeMap[gameObject.mapRow + 1][gameObject.mapColumn]     		  == WALL)    	{    	  wallCounter++;    	}	    	if(_mazeMap[gameObject.mapRow - 1][gameObject.mapColumn]     		  == WALL)    	{    	  wallCounter++;    	}	   	      	    	if(wallCounter > 2)    	{    	  objectIsAtIntersection = true;    	}    	    	return objectIsAtIntersection; 	  	  }	  	  //Find out wether a game object is precisely 	  //at the top left corner of the tile		public function atCornerOfTile(gameObject:TileModel):Boolean		{		  var objectIsAtCorner:Boolean = false;		  		  var tileCorner_X:uint 		    = gameObject.mapColumn * MAX_TILE_SIZE;		  var tileCorner_Y:uint 		    = gameObject.mapRow * MAX_TILE_SIZE; 		    		  if(uint(gameObject.xPos) == tileCorner_X		  && uint(gameObject.yPos) == tileCorner_Y)		  {		    objectIsAtCorner = true;		  }		  else		  {		    objectIsAtCorner = false;		  }		  		  return objectIsAtCorner;  		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {    for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)    {      for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)      {        var currentTile:int = map[mapRow][mapColumn];                if(currentTile > -1)        {          //Find the tile's column and row position          //on the tile sheet          var tileSheetColumn:uint = uint(currentTile / 10);          var tileSheetRow:uint = uint(currentTile % 10);                    switch(currentTile)          {            case FAIRY:              _fairyModel    	          = new TileModel    	          (    	            MAX_TILE_SIZE,    	            tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE    	          );   	            	        //Add the UIView and UIController      	        _UIMazeController    	          = new UIMazeController(_fairyModel);  	          _UIMazeView  		          = new UIMazeView  		          (_fairyModel, _UIMazeController, stage);    		            		        //Disable friction  		          _fairyModel.friction = 1;		          		          //Set the intial direction		          _fairyModel.direction = "right";		          		          //Blit the object to the stage    	        drawGameObject(_fairyModel, _foregroundBitmapData);    	        break;                        case MONSTER:              _monsterModel    	          = new TileModel    	          (    	            MAX_TILE_SIZE,    	            tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE    	          );     		            		        //Disable friction  		          _monsterModel.friction = 1;		          		          //Set the intial direction		          _monsterModel.direction = "up";		          		          //Blit the object to the stage    	        drawGameObject(_monsterModel, _foregroundBitmapData);    	        break;    	                    case WALL:              var wall:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,  	              tileSheetColumn, tileSheetRow,   	              mapRow, mapColumn,   	              MAX_TILE_SIZE, MAX_TILE_SIZE                );  	          drawGameObject(wall, _backgroundBitmapData);              break;                        case FLOOR:              var floor:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,  	              tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE                );  	          drawGameObject(floor, _backgroundBitmapData);              break;           }           }       }     }   }	    //Basic blit method   private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   		    tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point = new Point      (        tileModel.xPos,         tileModel.yPos      );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}