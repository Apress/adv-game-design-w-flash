package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="832", height="768",   backgroundColor="#FFFFFF", frameRate="60")]  	public class MoveAroundMaze extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 13;	  private const MAP_ROWS:uint = 12;	  	  //tile ID numbers in tile sheet	  private const WALL:uint = 00;	  private const FLOOR:uint = 10;	  private const FAIRY:uint = 01;	  private const MONSTER:uint = 11;	 	  private var _mazeMap:Array	    = [	        [00,00,00,00,00,00,00,00,00,00,00,00,00],	        [00,10,10,10,10,10,10,10,10,00,00,10,00],	        [00,10,00,10,00,00,10,00,10,10,10,10,00],	        [00,10,00,10,10,00,10,00,00,00,10,00,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,00,10,00,10,00,10,00,10,00,10,00],	        [00,10,10,10,00,10,00,00,00,10,00,10,00],	        [00,10,00,00,00,10,10,10,10,10,00,10,00],	        [00,10,10,10,10,10,00,00,10,00,00,10,00],	        [00,10,00,10,00,10,10,00,10,10,10,10,00],	        [00,10,10,10,00,00,10,10,10,00,10,10,00],	        [00,00,00,00,00,00,00,00,00,00,00,00,00]	      ];    	   	   private var _gameObjectMap:Array	    = [	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,01,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]	      ];	        	  //Create blank BitmapData objects as the canvas for the game    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);    private var _foregroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _foregroundBitmap:Bitmap       = new Bitmap(_foregroundBitmapData);  	  	//Tile sheet		[Embed(source="../../images/mazeTileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Create a TileModel to represent the fairy    private var _fairyModel:TileModel;    private var _UIMazeController:UIMazeController;    private var _UIMazeView:UIMazeView         //Status box  	private var _statusBox:StatusBox = new StatusBox;				public function MoveAroundMaze():void		{  		  //Draw the tile sheet			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the game bitmaps			addChild(_backgroundBitmap);			addChild(_foregroundBitmap);						//Add the status box			addChild(_statusBox);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_mazeMap);			buildMap(_gameObjectMap);						addEventListener			  (Event.ENTER_FRAME, enterFrameHandler);		}		private function enterFrameHandler(event:Event):void		{ 		  //1. UPDATE THE MODELS		  		  _fairyModel.update();		  		  //2. CHECK FOR COLLISIONS		  		  //Make a decision about which way to move if the		  //fairy's top left x and y position matches the		  //tile's top left x and y position		  if(atCornerOfTile(_fairyModel))		  {		    //Move in a new direction if there is no wall		    if(_fairyModel.direction == "left"  		  && _mazeMap[_fairyModel.mapRow][_fairyModel.mapColumn - 1]     		  == FLOOR)    		{  		    _fairyModel.vx = -8;  		    _fairyModel.vy = 0;  		  }      		  else if(_fairyModel.direction == "right"  		  && _mazeMap[_fairyModel.mapRow][_fairyModel.mapColumn + 1]     		  == FLOOR)    		{  		    _fairyModel.vx = 8;  		    _fairyModel.vy = 0;  		  }    		    		  else if(_fairyModel.direction == "up"  		  && _mazeMap[_fairyModel.mapRow - 1][_fairyModel.mapColumn]     		  == FLOOR)    		{  		    _fairyModel.vx = 0;  		    _fairyModel.vy = -8;  		  }    		    	    else if(_fairyModel.direction == "down"  		  && _mazeMap[_fairyModel.mapRow + 1][_fairyModel.mapColumn]     		  == FLOOR)    		{  		    _fairyModel.vx = 0;  		    _fairyModel.vy = 8;  		  }  		    		  //Stop if there is a wall in the current direction  		  if(_fairyModel.vx > 0  		  && _mazeMap[_fairyModel.mapRow][_fairyModel.mapColumn + 1]     		  == WALL)    		{    		  _fairyModel.vx = 0    		}      		else if(_fairyModel.vx < 0  		  && _mazeMap[_fairyModel.mapRow][_fairyModel.mapColumn - 1]     		  == WALL)    		{    		  _fairyModel.vx = 0    		}      		if(_fairyModel.vy > 0  		  && _mazeMap[_fairyModel.mapRow + 1][_fairyModel.mapColumn]     		  == WALL)    		{    		  _fairyModel.vy = 0    		}      		else if(_fairyModel.vy < 0  		  && _mazeMap[_fairyModel.mapRow - 1][_fairyModel.mapColumn]     		  == WALL)    		{    		  _fairyModel.vy = 0    		}        }      		  //3. BLIT THE OBJECTS		  		  //Clear the foreground		  _foregroundBitmapData.fillRect(_foregroundBitmapData.rect, 0);      		  //Blit the game objects		  drawGameObject(_fairyModel, _foregroundBitmapData);		  		  //Update status box			_statusBox.text = "MOVE AROUND MAZE:"; 			_statusBox.text 			  += "\n" + "DIRECTION: " + _fairyModel.direction;  	  }	  	  //Find out wether a game object is precisely 	  //at the top left corner of the tile		public function atCornerOfTile(gameObject:TileModel):Boolean		{		  var objectIsAtCorner:Boolean = false;		  		  var tileCorner_X:uint 		    = gameObject.mapColumn * MAX_TILE_SIZE;		  var tileCorner_Y:uint 		    = gameObject.mapRow * MAX_TILE_SIZE; 		    		  if(uint(gameObject.xPos) == tileCorner_X		  && uint(gameObject.yPos) == tileCorner_Y)		  {		    objectIsAtCorner = true;		  }		  else		  {		    objectIsAtCorner = false;		  }		  		  return objectIsAtCorner;  		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {    for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)    {      for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)      {        var currentTile:int = map[mapRow][mapColumn];                if(currentTile > -1)        {          //Find the tile's column and row position          //on the tile sheet          var tileSheetColumn:uint = uint(currentTile / 10);          var tileSheetRow:uint = uint(currentTile % 10);                    switch(currentTile)          {            case FAIRY:              _fairyModel    	          = new TileModel    	          (    	            MAX_TILE_SIZE,    	            tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE    	          );   	            	        //Add the UIView and UIController      	        _UIMazeController    	          = new UIMazeController(_fairyModel);  	          _UIMazeView  		          = new UIMazeView  		          (_fairyModel, _UIMazeController, stage);    		            		        //Disable friction  		          _fairyModel.friction = 1;		          		          //Set the intial direction		          _fairyModel.direction = "right";		          		          //Blit the object to the stage    	        drawGameObject(_fairyModel, _foregroundBitmapData);    	        break;                      case WALL:              var wall:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,  	              tileSheetColumn, tileSheetRow,   	              mapRow, mapColumn,   	              MAX_TILE_SIZE, MAX_TILE_SIZE                );  	          drawGameObject(wall, _backgroundBitmapData);              break;                        case FLOOR:              var floor:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,  	              tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE                );  	          drawGameObject(floor, _backgroundBitmapData);              break;           }           }       }     }   }	    //Basic blit method   private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   		    tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point = new Point      (        tileModel.xPos,         tileModel.yPos      );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}