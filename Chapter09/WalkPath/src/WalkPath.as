package{	import flash.events.Event;	import flash.events.MouseEvent;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="832", height="768",   backgroundColor="#FFFFFF", frameRate="60")]  	public class WalkPath extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 13;	  private const MAP_ROWS:uint = 12;	  	  //tile ID numbers in tile sheet	  private const WALL:uint = 00;	  private const FLOOR:uint = 10;	  private const FAIRY:uint = 01;	  	  	  private var _mazeMap:Array	    = [	        [00,00,00,00,00,00,00,00,00,00,00,00,00],	        [00,10,10,10,10,10,10,10,10,00,00,10,00],	        [00,10,00,10,00,00,10,00,10,10,10,10,00],	        [00,10,00,10,10,10,10,10,00,00,10,00,00],	        [00,10,10,10,00,10,00,10,10,10,10,10,00],	        [00,10,00,10,00,10,00,10,00,10,00,10,00],	        [00,10,10,10,00,10,00,00,00,10,00,10,00],	        [00,10,00,00,00,10,10,10,10,10,00,10,00],	        [00,10,10,10,10,10,00,00,10,00,10,10,00],	        [00,10,00,10,00,10,10,00,10,10,10,00,00],	        [00,10,10,10,00,00,10,10,10,00,10,10,00],	        [00,00,00,00,00,00,00,00,00,00,00,00,00]	      ];    	   	   private var _gameObjectMap:Array	    = [	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,01,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]	      ];	        	  //Create blank BitmapData objects as the canvas for the game    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);    private var _foregroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _foregroundBitmap:Bitmap       = new Bitmap(_foregroundBitmapData);  	  	//Tile sheet		[Embed(source="../../images/mazeTileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Create a TileModel to represent the fairy    private var _fairyModel:TileModel;    private var _UIMazeController:UIMazeController;    private var _UIMazeView:UIMazeView;        //Create a new AStar object    private var aStar:AStar = new AStar();      	//An array that stores the circles that mark the path		private var _pathMarkers:Array = [];        //Status box  	private var _statusBox:StatusBox = new StatusBox;				public function WalkPath():void		{  		  //Draw the tile sheet			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the game bitmaps			addChild(_backgroundBitmap);			addChild(_foregroundBitmap);						//Add the status box			addChild(_statusBox);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_mazeMap);			buildMap(_gameObjectMap);						stage.addEventListener			  (MouseEvent.MOUSE_DOWN, mouseDownHandler);			addEventListener			  (Event.ENTER_FRAME, enterFrameHandler);		}		private function mouseDownHandler(event:MouseEvent):void  	{  	  //Find the startNode  	  var playerColumn:uint = uint(_fairyModel.xPos / MAX_TILE_SIZE);  	  var playerRow:uint = uint(_fairyModel.yPos / MAX_TILE_SIZE);  	  var startNode_ID:uint = (playerColumn * 100) + playerRow;  	    	  //Find the destinationNode  		var mouseColumn:uint = uint(stage.mouseX / MAX_TILE_SIZE);  		var mouseRow:uint = uint(stage.mouseY / MAX_TILE_SIZE);  		var destinationNode_ID:uint  = (mouseColumn * 100) + mouseRow;  		  		//Note: To prevent A* from choosing a diagonal route  		//in an open area without walls, give it a high  		//diagonal cost, such as 30.  		var shortestPath:Array   		  = aStar.findShortestPath  		    (  		      startNode_ID,  		      destinationNode_ID,  		      _mazeMap,  		      WALL,  		      "manhattan",  		      10, 14  		    );  		  		//Display the path that's found  		//displayPath(shortestPath);  	}	  	  //Method to display the shortest path on the stage	  private function displayPath(shortestPath:Array):void  	{  	  //Clear any previous path that might be on the stage  	  while(_pathMarkers.length != 0)  	  {  	    removeChild(_pathMarkers.shift());  	  }        	  for(var j:int = 0; j < shortestPath.length; j++)      {        //Create a square shape the size of a tile  	    var shape:Shape = new Shape();		    shape.graphics.lineStyle(1);  			shape.graphics.beginFill(0x000000);  			shape.graphics.drawRect(0, 0, MAX_TILE_SIZE, MAX_TILE_SIZE);  			shape.graphics.endFill();  			addChild(shape);			  			//Plot the shape on the correct path tile  			shape.x = uint(shortestPath[j].id / 100) * MAX_TILE_SIZE;  			shape.y = uint(shortestPath[j].id % 100) * MAX_TILE_SIZE;  			  			_pathMarkers.push(shape);		  }	  }		private function enterFrameHandler(event:Event):void		{ 		  _fairyModel.update();		  		  //Make the _fairyModel move if it's at the corner of a tile		  //and if the shortestPath array isn't null		  if(atCornerOfTile(_fairyModel)		  && aStar.shortestPath != null)		  {		    //As long as there are elements in the shortestPath array,		    //make the _fairyModel move		    if(aStar.shortestPath.length != 0)		    {		      //Find the row and column in the path that the		      //_fairyModel has to walk to next  		    var nextColumn:uint = uint(aStar.shortestPath[0].id / 100);  		    var nextRow:uint = uint(aStar.shortestPath[0].id % 100);  		      		    //If the _fairyModel is on the start node,  		    //use the next node in the shortestPath array and remove the  		    //first one  		    if(_fairyModel.mapColumn == nextColumn  		    && _fairyModel.mapRow == nextRow)  		    {  		      //Find the next column and row in the path  		      nextColumn = uint(aStar.shortestPath[1].id / 100);  		      nextRow = uint(aStar.shortestPath[1].id % 100);  		        		      //Remove the current node  		      aStar.shortestPath.shift();  		    }		    		      //If the _fairyModel isn't standing on the next		      //column or row in the path, set her velocity		      //so that she starts walking in the right direction  		    if(_fairyModel.mapColumn != nextColumn)  		    {  		      if(_fairyModel.mapColumn > nextColumn)    		    {    		      //Move left    		      _fairyModel.vx = -8;      		    _fairyModel.vy = 0;    		    }    		    else    		    {    		      //Move right    		      _fairyModel.vx = 8;      		    _fairyModel.vy = 0;    		    }  	      }  	      else if(_fairyModel.mapRow != nextRow)  	      {  	        if(_fairyModel.mapRow > nextRow)    		    {    		      //Move up    		      _fairyModel.vx = 0;  		        _fairyModel.vy = -8;    		    }    		    else    		    {    		      //Move down    		      _fairyModel.vx = 0;  		        _fairyModel.vy = 8;    		    }  	      }  	        	      //Remove the current node from the path.  	      //This means that the path will gradually get shorter as  	      //the _fairyModel moves along it  	      aStar.shortestPath.shift();        }                //If there are no more elements left in the         //shortestPath array, stop the _fairyModel        else        {           _fairyModel.vx = 0;  		     _fairyModel.vy = 0;        }      }      		  //BLIT THE OBJECTS		  		  //Clear the foreground		  _foregroundBitmapData.fillRect(_foregroundBitmapData.rect, 0);      		  //Blit the game objects		  drawGameObject(_fairyModel, _foregroundBitmapData);		  		  //Update status box			_statusBox.text = "WALK PATH:"; 						if(aStar.startNode_ID != 0)			{			  _statusBox.text   			  += "\n" + "START: " + aStar.startNode_ID;    			_statusBox.text   			  += "\n" + "DESTINATION: " +  aStar.destinationNode_ID;        _statusBox.text += "\n" + "SHORTEST PATH: ";         if(aStar.shortestPath.length > 0)        {          for(var i:int = 0; i < aStar.shortestPath.length; i++)          {            _statusBox.text += aStar.shortestPath[i].id + ", ";          }        }        else        {          _statusBox.text += "No valid path chosen";        }        /*  			_statusBox.text += "\n";  			_statusBox.text += "\n" + "NODE MAP: " + "\n";    		  for  			   (  			     var mapRow:int = 0;   			     mapRow < MAP_ROWS;   			     mapRow++  			   )           {          for            (              var mapColumn:int = 0;               mapColumn < MAP_COLUMNS;               mapColumn++            )          {            _statusBox.text               += aStar.nodeMap[mapRow][mapColumn].id + ", ";                      if(mapColumn == aStar.nodeMap[mapRow].length -1)            {              _statusBox.text += "\n";            }          }        }        */      }	  }	  	  //Find out wether a game object is precisely 	  //at the top left corner of the tile		public function atCornerOfTile(gameObject:TileModel):Boolean		{		  var objectIsAtCorner:Boolean = false;		  		  var tileCorner_X:uint 		    = gameObject.mapColumn * MAX_TILE_SIZE;		  var tileCorner_Y:uint 		    = gameObject.mapRow * MAX_TILE_SIZE; 		    		  if(uint(gameObject.xPos) == tileCorner_X		  && uint(gameObject.yPos) == tileCorner_Y)		  {		    objectIsAtCorner = true;		  }		  else		  {		    objectIsAtCorner = false;		  }		  		  return objectIsAtCorner;  		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {    for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)    {      for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)      {        var currentTile:int = map[mapRow][mapColumn];                if(currentTile > -1)        {          //Find the tile's column and row position          //on the tile sheet          var tileSheetColumn:uint = uint(currentTile / 10);          var tileSheetRow:uint = uint(currentTile % 10);                    switch(currentTile)          {            case FAIRY:              _fairyModel    	          = new TileModel    	          (    	            MAX_TILE_SIZE,    	            tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE    	          );   	            	        //Add the UIView and UIController      	        _UIMazeController    	          = new UIMazeController(_fairyModel);  	          _UIMazeView  		          = new UIMazeView  		          (_fairyModel, _UIMazeController, stage);    		            		        //Disable friction  		          _fairyModel.friction = 1;		          		          //Set the intial direction		          _fairyModel.direction = "";		          		          //Blit the object to the stage    	        drawGameObject(_fairyModel, _foregroundBitmapData);    	        break;    	                    case WALL:              var wall:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,  	              tileSheetColumn, tileSheetRow,   	              mapRow, mapColumn,   	              MAX_TILE_SIZE, MAX_TILE_SIZE                );  	          drawGameObject(wall, _backgroundBitmapData);              break;                        case FLOOR:              var floor:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,  	              tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE                );  	          drawGameObject(floor, _backgroundBitmapData);              break;           }           }       }     }   }	    //Basic blit method   private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   		    tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point = new Point      (        tileModel.xPos,         tileModel.yPos      );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}