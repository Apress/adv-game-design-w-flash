package{	import flash.events.Event;	import flash.events.MouseEvent;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="832", height="768",   backgroundColor="#FFFFFF", frameRate="60")]  	public class ShortestPath extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 13;	  private const MAP_ROWS:uint = 12;	  	  //tile ID numbers in tile sheet	  private const WALL:uint = 00;	  private const FLOOR:uint = 10;	  private const FAIRY:uint = 01;	  	  /*	  private var _mazeMap:Array	    = [	        [00,00,00,00,00,00,00,00,00,00,00,00,00],	        [00,10,10,10,10,10,10,10,10,00,00,10,00],	        [00,10,00,10,00,00,10,00,10,10,10,10,00],	        [00,10,00,10,10,00,10,00,00,00,10,00,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,00,10,00,10,00,10,00,10,00,10,00],	        [00,10,10,10,00,10,00,00,00,10,00,10,00],	        [00,10,00,00,00,10,10,10,10,10,00,10,00],	        [00,10,10,10,10,10,00,00,10,00,00,10,00],	        [00,10,00,10,00,10,10,00,10,10,10,10,00],	        [00,10,10,10,00,00,10,10,10,00,10,10,00],	        [00,00,00,00,00,00,00,00,00,00,00,00,00]	      ];    	   */	   	   private var _mazeMap:Array	    = [	        [00,00,00,00,00,00,00,00,00,00,00,00,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,00,10,10,10,10,10,00],	        [00,10,10,10,10,10,00,00,00,00,10,10,00],	        [00,10,10,10,10,10,00,10,10,00,10,10,00],	        [00,10,10,10,10,10,00,00,10,00,10,10,00],	        [00,10,10,10,10,10,00,10,10,10,10,10,00],	        [00,10,10,10,10,10,00,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,00,00,00,00,00,00,00,00,00,00,00,00]	      ];    	    /*	    private var _mazeMap:Array	    = [	        [00,00,00,00,00,00,00,00,00,00,00,00,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,10,10,10,10,10,10,10,10,10,10,10,00],	        [00,00,00,00,00,00,00,00,00,00,00,00,00]	      ];    	    */    	   private var _gameObjectMap:Array	    = [	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,01,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],	        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]	      ];	        	  //Create blank BitmapData objects as the canvas for the game    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);    private var _foregroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _foregroundBitmap:Bitmap       = new Bitmap(_foregroundBitmapData);  	  	//Tile sheet		[Embed(source="../../images/mazeTileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Create a TileModel to represent the fairy    private var _fairyModel:TileModel;    private var _UIMazeController:UIMazeController;    private var _UIMazeView:UIMazeView;        //Initialize the AStar object    private var _aStar:AStar = new AStar();      	//An array that stores the circles that mark the path		private var _pathMarkers:Array = [];        //Status box  	private var _statusBox:StatusBox = new StatusBox;				public function ShortestPath():void		{  		  //Draw the tile sheet			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the game bitmaps			addChild(_backgroundBitmap);			addChild(_foregroundBitmap);						//Add the status box			addChild(_statusBox);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_mazeMap);			buildMap(_gameObjectMap);						stage.addEventListener			  (MouseEvent.MOUSE_DOWN, mouseDownHandler);			addEventListener			  (Event.ENTER_FRAME, enterFrameHandler);		}		private function mouseDownHandler(event:MouseEvent):void  	{  	  //1. Find the startNode  	  var playerColumn:uint = uint(_fairyModel.xPos / MAX_TILE_SIZE);  	  var playerRow:uint = uint(_fairyModel.yPos / MAX_TILE_SIZE);  	  var startNode_ID:uint = (playerColumn * 100) + playerRow;  	    	  //2. Find the destinationNode  		var mouseColumn:uint = uint(stage.mouseX / MAX_TILE_SIZE);  		var mouseRow:uint = uint(stage.mouseY / MAX_TILE_SIZE);  		var destinationNode_ID:uint  = (mouseColumn * 100) + mouseRow;  		  		//3. Get the array containing the shortest path  		//from the _aStar object  		var shortestPath:Array   		  = _aStar.findShortestPath  		    (  		      startNode_ID,  		      destinationNode_ID,  		      _mazeMap,  		      WALL,  		      "diagonal",  		      10, 14  		    );  		  		//4. Display the path that's found  		displayPath(shortestPath);  	}	  	  //Method to display the shortest path on the stage	  private function displayPath(shortestPath:Array):void  	{  	  //Clear any previous path that might be on the stage  	  while(_pathMarkers.length != 0)  	  {  	    removeChild(_pathMarkers.shift());  	  }        	  for(var i:int = 0; i < shortestPath.length; i++)      {        //Create a square shape the size of a tile  	    var shape:Shape = new Shape();		    shape.graphics.lineStyle(1);  			shape.graphics.beginFill(0x000000);  			shape.graphics.drawRect(0, 0, MAX_TILE_SIZE, MAX_TILE_SIZE);  			shape.graphics.endFill();  			addChild(shape);			  			//Plot the shape on the correct path tile  			shape.x = uint(shortestPath[i].id / 100) * MAX_TILE_SIZE;  			shape.y = uint(shortestPath[i].id % 100) * MAX_TILE_SIZE;  			  			_pathMarkers.push(shape);		  }	  }		private function enterFrameHandler(event:Event):void		{ 		  //1. UPDATE THE MODELS		  		  _fairyModel.update();		  		  //2. CHECK FOR COLLISIONS		  		  		  //Make a decision about which way to move if the		  //fairy's top left x and y position matches the		  //tile's top left x and y position		  if(atCornerOfTile(_fairyModel))		  {		    //Move in a new direction if there is no wall		    if(_fairyModel.direction == "left"  		  && _mazeMap[_fairyModel.mapRow][_fairyModel.mapColumn - 1]     		  == FLOOR)    		{  		    _fairyModel.vx = -8;  		    _fairyModel.vy = 0;  		  }      		  else if(_fairyModel.direction == "right"  		  && _mazeMap[_fairyModel.mapRow][_fairyModel.mapColumn + 1]     		  == FLOOR)    		{  		    _fairyModel.vx = 8;  		    _fairyModel.vy = 0;  		  }    		    		  else if(_fairyModel.direction == "up"  		  && _mazeMap[_fairyModel.mapRow - 1][_fairyModel.mapColumn]     		  == FLOOR)    		{  		    _fairyModel.vx = 0;  		    _fairyModel.vy = -8;  		  }    		    	    else if(_fairyModel.direction == "down"  		  && _mazeMap[_fairyModel.mapRow + 1][_fairyModel.mapColumn]     		  == FLOOR)    		{  		    _fairyModel.vx = 0;  		    _fairyModel.vy = 8;  		  }  		    		  //Stop if there is a wall in the current direction  		  if(_fairyModel.vx > 0  		  && _mazeMap[_fairyModel.mapRow][_fairyModel.mapColumn + 1]     		  == WALL)    		{    		  _fairyModel.vx = 0;    		}      		else if(_fairyModel.vx < 0  		  && _mazeMap[_fairyModel.mapRow][_fairyModel.mapColumn - 1]     		  == WALL)    		{    		  _fairyModel.vx = 0;    		}      		if(_fairyModel.vy > 0  		  && _mazeMap[_fairyModel.mapRow + 1][_fairyModel.mapColumn]     		  == WALL)    		{    		  _fairyModel.vy = 0    		}      		else if(_fairyModel.vy < 0  		  && _mazeMap[_fairyModel.mapRow - 1][_fairyModel.mapColumn]     		  == WALL)    		{    		  _fairyModel.vy = 0;    		}        }      		  //3. BLIT THE OBJECTS		  		  //Clear the foreground		  _foregroundBitmapData.fillRect(_foregroundBitmapData.rect, 0);      		  //Blit the game objects		  drawGameObject(_fairyModel, _foregroundBitmapData);		  		  //Update status box			_statusBox.text = "SHORTEST PATH:"; 						if(_aStar.startNode_ID != 0)			{			  _statusBox.text   			  += "\n" + "START: " + _aStar.startNode_ID;    			_statusBox.text   			  += "\n" + "DESTINATION: " +  _aStar.destinationNode_ID;        _statusBox.text += "\n" + "SHORTEST PATH: ";         if(_aStar.shortestPath.length > 0)        {          for(var i:int = 0; i < _aStar.shortestPath.length; i++)          {            _statusBox.text += _aStar.shortestPath[i].id + ", ";          }        }        else        {          _statusBox.text += "No valid path chosen";        }  			_statusBox.text += "\n";  			_statusBox.text += "\n" + "NODE MAP: " + "\n";    		  for  			   (  			     var mapRow:int = 0;   			     mapRow < MAP_ROWS;   			     mapRow++  			   )           {          for            (              var mapColumn:int = 0;               mapColumn < MAP_COLUMNS;               mapColumn++            )          {            _statusBox.text               += _aStar.nodeMap[mapRow][mapColumn].id + ", ";                      if(mapColumn == _aStar.nodeMap[mapRow].length -1)            {              _statusBox.text += "\n";            }          }        }      }	  }	  	  //Find out wether a game object is precisely 	  //at the top left corner of the tile		public function atCornerOfTile(gameObject:TileModel):Boolean		{		  var objectIsAtCorner:Boolean = false;		  		  var tileCorner_X:uint 		    = gameObject.mapColumn * MAX_TILE_SIZE;		  var tileCorner_Y:uint 		    = gameObject.mapRow * MAX_TILE_SIZE; 		    		  if(uint(gameObject.xPos) == tileCorner_X		  && uint(gameObject.yPos) == tileCorner_Y)		  {		    objectIsAtCorner = true;		  }		  else		  {		    objectIsAtCorner = false;		  }		  		  return objectIsAtCorner;  		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {    for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)    {      for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)      {        var currentTile:int = map[mapRow][mapColumn];                if(currentTile > -1)        {          //Find the tile's column and row position          //on the tile sheet          var tileSheetColumn:uint = uint(currentTile / 10);          var tileSheetRow:uint = uint(currentTile % 10);                    switch(currentTile)          {            case FAIRY:              _fairyModel    	          = new TileModel    	          (    	            MAX_TILE_SIZE,    	            tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE    	          );   	            	        //Add the UIView and UIController      	        _UIMazeController    	          = new UIMazeController(_fairyModel);  	          _UIMazeView  		          = new UIMazeView  		          (_fairyModel, _UIMazeController, stage);    		            		        //Disable friction  		          _fairyModel.friction = 1;		          		          //Set the intial direction		          _fairyModel.direction = "";		          		          //Blit the object to the stage    	        drawGameObject(_fairyModel, _foregroundBitmapData);    	        break;    	                    case WALL:              var wall:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,  	              tileSheetColumn, tileSheetRow,   	              mapRow, mapColumn,   	              MAX_TILE_SIZE, MAX_TILE_SIZE                );  	          drawGameObject(wall, _backgroundBitmapData);              break;                        case FLOOR:              var floor:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,  	              tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE                );  	          drawGameObject(floor, _backgroundBitmapData);              break;           }           }       }     }   }	    //Basic blit method   private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   		    tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point = new Point      (        tileModel.xPos,         tileModel.yPos      );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}