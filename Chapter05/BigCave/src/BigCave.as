package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Matrix;  import flash.filters.*;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.lunarLander.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   _caveBitmapColor="#FFFFFF", frameRate="60")]  	public class BigCave extends Sprite	{			//Create the lander and add its UI controller  		private var _lander:LanderModel   		  = new LanderModel(30,30);  		private var _landerUIController:LanderUIController   		  = new LanderUIController(_lander);  		private var _lander_View:LanderView   		  = new LanderView(_lander);  		private var _landerUIView:LanderUIView   		  = new LanderUIView(_lander, _landerUIController, stage);  		  		//Variable to check the side of the lander that the collision  		//is occuring on.   		//(This is just used for display in the status box.)  		private var _collisionSide:String = "";						//Variables required to display the cave			private var _caveBitmap:Bitmap;			private var _caveImage:DisplayObject;			private var _caveBitmapData:BitmapData;						//Map objects			private var _mapBitmapData:BitmapData;			private var _mapBitmap:Bitmap;						//Map marker			private var _mapMarker:Shape = new Shape();						//Variables required for scrolling			private var _rightInnerBoundary:Number 			  = (stage.stageWidth * 0.5) + (stage.stageWidth * 0.25);			private var _leftInnerBoundary:Number 			  = (stage.stageWidth * 0.5) - (stage.stageWidth * 0.25);			private var _topInnerBoundary:Number 			  = (stage.stageHeight * 0.5) - (stage.stageHeight * 0.25);			private var _bottomInnerBoundary:Number 			  = (stage.stageHeight * 0.5) + (stage.stageHeight * 0.25);						//Embed the image of the cave      [Embed(source="../assets/images/bigCave.png")]      private var CaveImage:Class;				public function BigCave():void		{ 		  //Add the lander to the stage			addChild(_lander_View);			_lander.setX = 100;			_lander.setY = 200;						//Add gravity			_lander.gravity_Vy = 0.1;						//Create a new instance of the _caveImage class			_caveImage = new CaveImage();						//Create a BitmapData object to store the image.			_caveBitmapData 			  = new BitmapData			  (_caveImage.width, _caveImage.height, true, 0);			  			_caveBitmapData.draw(_caveImage);						//Create and add the cave bitmap image			_caveBitmap = new Bitmap(_caveBitmapData);			addChild(_caveBitmap);			_caveBitmap.x = 0;			_caveBitmap.y = 0;						//Create a map based on the bitmap:						//1. Determine the scale factor			var scaleFactor:Number = 0.04;						//2. Determine the map's size based 			//on the _caveBitmap's full height and width      var mapWidth:Number = _caveBitmapData.width * scaleFactor;      var mapHeight:Number = _caveBitmapData.height * scaleFactor;            /*      trace        (          _caveBitmapData.width,           _caveBitmapData.height,           mapWidth,           mapHeight        );      */            //3. Create the map's BitmapData based on       //the scaled height and width      var _mapBitmapData:BitmapData         = new BitmapData(mapWidth, mapHeight, false, 0x000000);            //4. Create a Matrix to scale the       //cave's BitmapData to the new size      var scaleMatrix:Matrix = new Matrix();      scaleMatrix.scale(scaleFactor, scaleFactor);            //5. Use the scaled Matrix along with the _caveBitmapData to       //draw the scaled image of the cave into the _mapBitmapData      _mapBitmapData.draw(_caveBitmapData, scaleMatrix);            //6. Create the map's Bitmap using the new scaled _mapBitmapData      _mapBitmap = new Bitmap(_mapBitmapData);            //Add bevel and drop shadow filters to the map      var filters:Array = [];			filters = _mapBitmap.filters;			filters.push			  (			    new BevelFilter			    (			      2, 135, 0xFFFFFF, 0.50, 			      0x000000, 0.50, 2, 2			    )			  );			filters.push			  (			    new DropShadowFilter			    (			      3, 135, 0x000000, 			      0.75, 2, 2			    )			  );			  			_mapBitmap.filters = filters;            //Add the map at the top left hand corner of the stage			addChild(_mapBitmap);			_mapBitmap.x = 3;			_mapBitmap.y = 2;						//Create the map marker			_mapMarker.graphics.lineStyle();			_mapMarker.graphics.beginFill(0xFFFF00);			_mapMarker.graphics.drawRect(-2,-2,4,4);			_mapMarker.graphics.endFill();			addChild(_mapMarker);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{ 						//Update the lander			_lander.update();			StageBoundaries.wrapBitmap(_lander, stage); 						//Position the map marker			_mapMarker.x 			  = _mapBitmap.x + ((-_caveBitmap.x + _lander.xPos) * 0.04);			_mapMarker.y 			  = _mapBitmap.y + ((-_caveBitmap.y + _lander.yPos) * 0.04);						//Scrolling						//Stop player at inner boundary edges			if (_lander.xPos < _leftInnerBoundary)			{				_lander.setX = _leftInnerBoundary;				_rightInnerBoundary 				  = (stage.stageWidth * 0.5) + (stage.stageWidth * 0.25);				_caveBitmap.x -= _lander.vx;			}			else if (_lander.xPos + _lander.width > _rightInnerBoundary)			{				_lander.setX = _rightInnerBoundary - _lander.width;				_leftInnerBoundary 				  = (stage.stageWidth * 0.5) - (stage.stageWidth * 0.25);				_caveBitmap.x -= _lander.vx;			}			if (_lander.yPos < _topInnerBoundary)			{				_lander.setY = _topInnerBoundary;				_bottomInnerBoundary 				  = (stage.stageHeight * 0.5) + (stage.stageHeight * 0.25);				_caveBitmap.y -= _lander.vy;			}			else if (_lander.yPos + _lander.height > _bottomInnerBoundary)			{				_lander.setY = _bottomInnerBoundary - _lander.height;				_topInnerBoundary 				  = (stage.stageHeight * 0.5) - (stage.stageHeight * 0.25);				_caveBitmap.y -= _lander.vy;			}						//Stop _caveBitmap at stage edges			if (_caveBitmap.x + _caveBitmap.width < stage.stageWidth)			{				_caveBitmap.x = stage.stageWidth - _caveBitmap.width;				_rightInnerBoundary = stage.stageWidth;			}			else if (_caveBitmap.x > 0)			{				_caveBitmap.x = 0;				_leftInnerBoundary = 0;			}			if (_caveBitmap.y > 0)			{				_caveBitmap.y = 0;				_topInnerBoundary = 0;			}			else if (_caveBitmap.y + _caveBitmap.height < stage.stageHeight)			{				_caveBitmap.y = stage.stageHeight - _caveBitmap.height;				_bottomInnerBoundary = stage.stageHeight;			}						//Collison						var landerBitmap:Object = createBitmap(_lander, _lander_View);						var loopCounter:int = 0;		  while (loopCounter++ != 10) 		  {			  if(landerBitmap.bitmapData.hitTest			      (			        new Point(_lander.xPos, _lander.yPos), 			        255, 			        _caveBitmap,			        new Point(_caveBitmap.x, _caveBitmap.y),			        255			      )			    )			  {    			    //Switch off gravity			 	  _lander.gravity_Vy = 0;			 	  			    //Create "collision boxes" on all 			    //four sides of the lander to			    //find out which side the collision is occuring on			    			    //Check for a collision on the bottom			    if(landerBitmap.bitmapData.hitTest			        (			          new Point(_lander.xPos, _lander.yPos + 10), 			          255, 			          _caveBitmap,			          new Point(_caveBitmap.x, _caveBitmap.y),			          255			        )			      )			    {			      //Move the lander out of the collision			      _lander.setY = _lander.yPos - 1;			      _lander.vy = 0;			    }			    			    //Check for a collision on the top			    else if			      (landerBitmap.bitmapData.hitTest			        (			          new Point(_lander.xPos, _lander.yPos - 10), 			          255, 			          _caveBitmap,			          new Point(_caveBitmap.x, _caveBitmap.y),			          255			        )			      )			    {			      //Move the lander out of the collision			      _lander.setY = _lander.yPos + 1;			      _lander.vy = 0;			    } 			    			    //Check for a collision on the right			    if(landerBitmap.bitmapData.hitTest			        (			          new Point(_lander.xPos + 10, _lander.yPos), 			          255, 			          _caveBitmap,			          new Point(_caveBitmap.x, _caveBitmap.y),			          255			        )			      )			    {			      //Move the lander out of the collision			      _lander.setX = _lander.xPos - 1;			      _lander.vx = 0;			    }			    			    //Check for a collision on the left 			    else if			      (landerBitmap.bitmapData.hitTest			        (			          new Point(_lander.xPos - 10, _lander.yPos), 			          255, 			          _caveBitmap,			          new Point(_caveBitmap.x, _caveBitmap.y),			          255			        )			      )			    {			      //Collision on left			      _lander.setX = _lander.xPos + 1;			      _lander.vx = 0;			    }                      			  } 			  else 			  {			    break;			  }		  }		  		  //Switch gravity back on if there is no ground below the lander		  //This example uses +3 to give it a bit 		  //more clearance. This prevents		  //the lander from "wobbling" on steep inlcines		  if(!landerBitmap.bitmapData.hitTest		      (		        new Point(_lander.xPos, _lander.yPos + 3), 			      255, 			      _caveBitmap,			      new Point(_caveBitmap.x, _caveBitmap.y),			      255			    )			  )			{			  _lander.gravity_Vy = 0.1;		  }		}		private function createBitmap		  (model:AVerletModel, view:AVerletView):Object		{		  //BitmapData(width, height, transparent?, fillColor(0 is alpha))			var bitmapData:BitmapData 			  = new BitmapData(model.width, model.height, true, 0);			bitmapData.draw(view);			var bitmap:Bitmap = new Bitmap(bitmapData);						//Create the star object to return to the caller			var bitmapObject:Object = new Object;			bitmapObject.bitmapData = bitmapData;			bitmapObject.bitmap = bitmap;						return bitmapObject;		}	}}