package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Matrix;  import flash.filters.*;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.lunarLander.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   _caveBitmapColor="#FFFFFF", frameRate="60")]  	public class CaveObjects extends Sprite	{			//Create the lander and add its UI controller   		private var _lander:LanderModel   		  = new LanderModel(30,30);  		private var _landerUIController:LanderUIController   		  = new LanderUIController(_lander);  		private var _lander_View:LanderView = new LanderView(_lander);  		private var _landerUIView:LanderUIView   		  = new LanderUIView(_lander, _landerUIController, stage);						//Variables required to display the cave bitmap			private var _caveBitmap:Bitmap;			private var _caveImage:DisplayObject;			private var _caveBitmapData:BitmapData;						//Map objects			private var _mapImage:DisplayObject;			private var _mapBitmapData:BitmapData;			private var _mapBitmap:Bitmap;						//Map marker			private var _mapMarker:Shape = new Shape();						//Variables required for scrolling			private var _rightInnerBoundary:Number 			  = (stage.stageWidth * 0.5) + (stage.stageWidth * 0.25);			private var _leftInnerBoundary:Number 			  = (stage.stageWidth * 0.5) - (stage.stageWidth * 0.25);			private var _topInnerBoundary:Number 			  = (stage.stageHeight * 0.5) - (stage.stageHeight * 0.25);			private var _bottomInnerBoundary:Number 			  = (stage.stageHeight * 0.5) + (stage.stageHeight * 0.25);						//An array to store the orbs			private var _orbs:Array = [];						//A 2 dimensional array to store the orb positions			private var _orbPositions:Array =			[			  [969,378], 			  [1298,1045], 			  [2109,1696], 			  [2301,700]			];			                                      			//An array to store the orb map markers			private var _orbMarkers:Array = [];						//Embed the image of the cave      [Embed(source="../assets/images/bigCave.png")]      private var CaveImage:Class;				public function CaveObjects():void		{ 		  //Add the lander to the stage			addChild(_lander_View);			_lander.setX = 100;			_lander.setY = 200;						//Add gravity			_lander.gravity_Vy = 0.1;						//Create a new instance of the _caveImage class			_caveImage = new CaveImage();						//Create a BitmapData object to store the image			_caveBitmapData 			  = new BitmapData			  (_caveImage.width, _caveImage.height, true, 0);			_caveBitmapData.draw(_caveImage);						//Create and add the cave bitmap image			_caveBitmap = new Bitmap(_caveBitmapData);			addChild(_caveBitmap);			_caveBitmap.x = 0;			_caveBitmap.y = 0;						//Create the orbs and add them 			//to the _orbs array			for(var i:int = 0; i < _orbPositions.length; i++)      {        //Create the orb        var orb:Shape = new Shape();        orb.graphics.lineStyle();			  orb.graphics.beginFill(0x00FF00);			  orb.graphics.drawCircle(-15,-15, 15);			  orb.graphics.endFill();			  			  //Add filters to the orbs			  var orbFilters:Array = [];			  orbFilters = orb.filters;			  orbFilters.push			    (			      new BevelFilter			      (			        2, 135, 0xFFFFFF, 0.50, 			        0x000000, 0.50, 2, 2			      )			    );			  orbFilters.push			    (			      new DropShadowFilter			      (			        2, 135, 0x000000, 			        0.35, 2, 2			      )			    );			  orb.filters = orbFilters;			  			  //Add the orb to the _orbs array         _orbs.push(orb);                //Add the orb to the stage        addChild(orb);        			  //Set the initial orb positions			  orb.x = _caveBitmap.x + _orbPositions[i][0];			  orb.y = _caveBitmap.y + _orbPositions[i][1];      }						//Create a map based on the bitmap			var scaleFactor:Number = 0.04;      var mapWidth:Number = _caveBitmapData.width * scaleFactor;      var mapHeight:Number = _caveBitmapData.height * scaleFactor;      var _mapBitmapData:BitmapData         = new BitmapData(mapWidth, mapHeight, false, 0x000000);      var scaleMatrix:Matrix = new Matrix();      scaleMatrix.scale(scaleFactor, scaleFactor);      _mapBitmapData.draw(_caveBitmapData, scaleMatrix);      _mapBitmap = new Bitmap(_mapBitmapData);            //Add bevel and drop shadow filters to the map      var filters:Array = [];			filters = _mapBitmap.filters;			filters.push			  (			    new BevelFilter			    (			      2, 135, 0xFFFFFF, 0.50, 			      0x000000, 0.50, 2, 2			    )			  );			filters.push			  (			    new DropShadowFilter			    (			      3, 135, 0x000000, 			      0.75, 2, 2			    )			  );			_mapBitmap.filters = filters;						//Add the map at the top left hand corner of the stage			addChild(_mapBitmap);			_mapBitmap.x = 3;			_mapBitmap.y = 2;						//Create the lander's map marker			_mapMarker.graphics.lineStyle();			_mapMarker.graphics.beginFill(0xFFFF00);			_mapMarker.graphics.drawRect(-2,-2,4,4); 			_mapMarker.graphics.endFill();			addChild(_mapMarker);      			//Create the map markers and add them 			//to the _mapMarkers array			for(var j:int = 0; j < _orbPositions.length; j++)      {        var mapMarker:Shape = new Shape();        mapMarker.graphics.lineStyle();			  mapMarker.graphics.beginFill(0x00FF00);			  mapMarker.graphics.drawRect(-2,-2,4,4);			  mapMarker.graphics.endFill();        _orbMarkers.push(mapMarker);        addChild(mapMarker);                //Position the marker        mapMarker.x           = _mapBitmap.x + ((-_caveBitmap.x + _orbs[j].x) * 0.04);        mapMarker.y           = _mapBitmap.y + ((-_caveBitmap.y + _orbs[j].y) * 0.04);      }						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{ 						//Update the lander			_lander.update();			StageBoundaries.wrapBitmap(_lander, stage); 						//Capture the current background x and y positions before 			//they're changed by scrolling	    var temporaryX:Number = _caveBitmap.x;	    var temporaryY:Number = _caveBitmap.y;						//Scrolling						//Stop player at inner boundary edges			if (_lander.xPos < _leftInnerBoundary)			{				_lander.setX = _leftInnerBoundary;				_rightInnerBoundary 				  = (stage.stageWidth * 0.5) + (stage.stageWidth * 0.25);				_caveBitmap.x -= _lander.vx;			}			else if (_lander.xPos + _lander.width > _rightInnerBoundary)			{				_lander.setX = _rightInnerBoundary - _lander.width;				_leftInnerBoundary 				  = (stage.stageWidth * 0.5) - (stage.stageWidth * 0.25);				_caveBitmap.x -= _lander.vx;			}			if (_lander.yPos < _topInnerBoundary)			{				_lander.setY = _topInnerBoundary;				_bottomInnerBoundary 				  = (stage.stageHeight * 0.5) + (stage.stageHeight * 0.25);				_caveBitmap.y -= _lander.vy;			}			else if (_lander.yPos + _lander.height > _bottomInnerBoundary)			{				_lander.setY = _bottomInnerBoundary - _lander.height;				_topInnerBoundary 				  = (stage.stageHeight * 0.5) - (stage.stageHeight * 0.25);				_caveBitmap.y -= _lander.vy;			}						//Stop _caveBitmap at stage edges			if (_caveBitmap.x + _caveBitmap.width < stage.stageWidth)			{				_caveBitmap.x = stage.stageWidth - _caveBitmap.width;				_rightInnerBoundary = stage.stageWidth;			}			else if (_caveBitmap.x > 0)			{				_caveBitmap.x = 0;				_leftInnerBoundary = 0;			}			if (_caveBitmap.y > 0)			{				_caveBitmap.y = 0;				_topInnerBoundary = 0;			}			else if (_caveBitmap.y + _caveBitmap.height < stage.stageHeight)			{				_caveBitmap.y = stage.stageHeight - _caveBitmap.height;				_bottomInnerBoundary = stage.stageHeight;			}						//Calculate the scroll velocity			var scroll_Vx:Number = _caveBitmap.x - temporaryX;			var scroll_Vy:Number = _caveBitmap.y - temporaryY;						//Position the lander's map marker			_mapMarker.x 			  = _mapBitmap.x + ((-_caveBitmap.x + _lander.xPos) * 0.04);			_mapMarker.y 			  = _mapBitmap.y + ((-_caveBitmap.y + _lander.yPos) * 0.04);						//Scroll the orbs	    for(var i:int = 0; i < _orbs.length; i++)      {        _orbs[i].x += scroll_Vx;        _orbs[i].y += scroll_Vy;                //Optionally use this code if your         //game objects have fixed positions        //_orbs[i].x = _caveBitmap.x + _orbPositions[i][0];        //_orbs[i].y = _caveBitmap.y + _orbPositions[i][1];      }						//Collison						var landerBitmap:Object = createBitmap(_lander, _lander_View);						//Check for a collision between the Lander and the cave			var loopCounter:int = 0;		  while (loopCounter++ != 10) 		  {			  if(landerBitmap.bitmapData.hitTest			      (			        new Point(_lander.xPos, _lander.yPos), 			        255, 			        _caveBitmap,			        new Point(_caveBitmap.x, _caveBitmap.y),			        255			      )			    )			  { 			    //A collision was found.	        //Next the code creates "collision boxes" on all     	    //four sides of the Lander to    	    //find out on which side the collision is occuring    	    			    //Switch off gravity			 	  _lander.gravity_Vy = 0;			    			    //1. Check for a collision on the bottom			    if(landerBitmap.bitmapData.hitTest			        (			          new Point(_lander.xPos, _lander.yPos + 10), 			          255, 			          _caveBitmap,			          new Point(_caveBitmap.x, _caveBitmap.y),			          255			        )			      )			    {			      //Move the lander out of the collision			      _lander.setY = _lander.yPos - 1;			      _lander.vy = 0;			    }			    			    //2. Check for a collision on the top			    else if			      (landerBitmap.bitmapData.hitTest			        (			          new Point(_lander.xPos, _lander.yPos - 10), 			          255, 			          _caveBitmap,			          new Point(_caveBitmap.x, _caveBitmap.y),			          255			        )			      )			    {			      //Move the lander out of the collision			      _lander.setY = _lander.yPos + 1;			      _lander.vy = 0;			    } 			    			    //3. Check for a collision on the right			    if(landerBitmap.bitmapData.hitTest			        (			          new Point(_lander.xPos + 10, _lander.yPos), 			          255, 			          _caveBitmap,			          new Point(_caveBitmap.x, _caveBitmap.y),			          255			        )			      )			    {			      //Move the lander out of the collision			      _lander.setX = _lander.xPos - 1;			      _lander.vx = 0;			    }			    			    //4. Check for a collision on the left 			    else if			      (landerBitmap.bitmapData.hitTest			        (			          new Point(_lander.xPos - 10, _lander.yPos), 			          255, 			          _caveBitmap,			          new Point(_caveBitmap.x, _caveBitmap.y),			          255			        )			      )			    {			      //Collision on left			      _lander.setX = _lander.xPos + 1;			      _lander.vx = 0;			    }                      			  } 			  else 			  {			    break;			  }		  }		  //Switch gravity back on if there is no ground below the lander		  //Adding "+1" to the lander's y position in the collision		  //test is the key to making this work		  if(!landerBitmap.bitmapData.hitTest		      (		        new Point(_lander.xPos, _lander.yPos + 1), 			      255, 			      _caveBitmap,			      new Point(_caveBitmap.x, _caveBitmap.y),			      255			    )			  )			{			  _lander.gravity_Vy = 0.1;		  }		        		}		private function createBitmap		  (model:AVerletModel, view:AVerletView):Object		{		  //BitmapData(width, height, transparent?, fillColor(0 is alpha))			var bitmapData:BitmapData 			  = new BitmapData(model.width, model.height, true, 0);			bitmapData.draw(view);			var bitmap:Bitmap = new Bitmap(bitmapData);						//Create the star object to return to the caller			var bitmapObject:Object = new Object;			bitmapObject.bitmapData = bitmapData;			bitmapObject.bitmap = bitmap;						return bitmapObject;		}	}}