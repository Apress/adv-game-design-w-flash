package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import com.friendsofed.utils.*;  import com.friendsofed.vector.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="640", height="512",   backgroundColor="#FFFFFF", frameRate="60")]  	public class XMLMap extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 10;	  private const MAP_ROWS:uint = 8;	  	  //The PLATFORM and SKY constants define	  //the position of tile images in the tile sheet	  private const PLATFORM:uint = 00;	  private const SKY:uint = 10;	  	  private var _levelName:String = "";	  private var _platformMap:Array = [];	   	  //Create a blank BitmapData object as the canvas for this bitmap    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);  	  	//Tile sheet  	//Variables required to display the tile sheet bitmap		[Embed(source="../../images/tileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Status box  	private var _statusBox:StatusBox = new StatusBox;				//Embed the XML file		[Embed(source = "../assets/xml/maps.xml",		mimeType = "application/octet-stream")]    private var XmlData:Class;				public function XMLMap():void		{ 		  //Create the map array from the XML file		  		  //1. Create the XmlData object		  var level:Object = new XmlData();		  		  //2. Cast it as an XML object. The name of the object		  //should preferably match the first XML element		  level = XML(level);		  		  //3. Create an XMLList object to help you loop through		  //all the row elements		  var rowList:XMLList = level.row;		  		  //4. Loop through each row 		  for each(var row:XML in rowList)		  {		    //5. Convert the row text node into a string		    var rowString:String = row.text();		    		    //6. Convert the string into an array.        //Commas in the XML file are used to        //separate each array element        //This array represents one <row> in the XML document		    var rowArray:Array = rowString.split(",");		    		    //7. Push the row array into the _platformMap array.        //This creates a 2D level map         //which will contain all 8 rows by the time the loop quits		    _platformMap.push(rowArray);      }            //Capture the level "name" attribute like this:      //and store it in the _levelName variable      _levelName = level.@name;      		  //Draw the tile sheet			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the stage bitmap			addChild(_backgroundBitmap);						//Run the buildMap method to convert the			//map's array data into a visual display			buildMap(_platformMap);						//Add the status box			addChild(_statusBox);						//Update status box			_statusBox.text = "XML MAP:"; 			_statusBox.text += "\n" + "NAME: " + _levelName; 			_statusBox.text += "\n" + "TILE SIZE: " + MAX_TILE_SIZE; 			_statusBox.text += "\n" + "MAP_ROWS: " + MAP_ROWS;  			_statusBox.text += "\n" + "MAP_COLUMNS: " + MAP_COLUMNS; 		}				//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {	  	    //Loop through all the cells in the game map      for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)      {        for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)        {          //Find out which tile ID number is in          //the current cell. This will be either          //"00" (a platform) or "01" (sky)          var currentTile:int = map[mapRow][mapColumn];                    //"-1" means that the tile destination grid will be blank          //This example doesn't use any blank tiles          if(currentTile > -1)          {            //Find the tile's column and row position            //on the tile sheet            var tileSheetColumn:uint               = uint(currentTile / 10);            var tileSheetRow:uint               = uint(currentTile % 10);                        //Now the code checks what type of tile            //the ID numbers says should be in the            //game map's grid cell            switch (currentTile)             {              case PLATFORM:                //If it finds a match it creates                //a TileModel object                var platform:TileModel = new TileModel();                platform.tileSheetColumn = tileSheetColumn;        	      platform.tileSheetRow = tileSheetRow;                platform.mapRow = mapRow;                platform.mapColumn = mapColumn;                platform.width = MAX_TILE_SIZE;                platform.height = MAX_TILE_SIZE;                platform.setX = mapColumn * MAX_TILE_SIZE;        	      platform.setY = mapRow * MAX_TILE_SIZE;  	                	      //Blit the tile from the tile sheet onto the        	      //background bitmap using the        	      //drawGameObject method        	      drawGameObject(platform, _backgroundBitmapData);                break;                              case SKY:                //Create a TileModel object                var sky:TileModel = new TileModel();                sky.tileSheetColumn = tileSheetColumn;        	      sky.tileSheetRow = tileSheetRow;                sky.mapRow = mapRow;                sky.mapColumn = mapColumn;                sky.width = MAX_TILE_SIZE;                sky.height = MAX_TILE_SIZE;                sky.setX = mapColumn * MAX_TILE_SIZE;        	      sky.setY = mapRow * MAX_TILE_SIZE;  	                	      //Blit the tile from the tile sheet onto the        	      //background bitmap         	      drawGameObject(sky, _backgroundBitmapData);                break;           }         }       }     }   }      //Basic blit method   private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle 		    = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   		    tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point   	    = new Point        (          tileModel.xPos,           tileModel.yPos        );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}