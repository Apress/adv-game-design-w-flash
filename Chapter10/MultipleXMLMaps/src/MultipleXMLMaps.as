package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import flash.geom.Matrix;  import flash.utils.getTimer;  import com.friendsofed.utils.*;  import com.friendsofed.vector.*;  import com.friendsofed.gameElements.primitives.*;  [SWF(width="640", height="512",   backgroundColor="#FFFFFF", frameRate="60")]  	public class MultipleXMLMaps extends Sprite	{	  private const MAX_TILE_SIZE:uint = 64;	  private const MAP_COLUMNS:uint = 10;	  private const MAP_ROWS:uint = 8;	  	  //Tile ID numbers in tile sheet	  private const PLATFORM:uint = 00;	  private const SKY:uint = 10;	  private const CAT:uint = 20;	  private const SOFT_PLATFORM:uint = 01;	  private const DOOR:uint = 23;	  	  //Arrays to store the platforms and game objects    private var _platformMapContainer:Array = [];    private var _gameObjectMapContainer:Array = [];        //An array to store the level names    private var _levelNames:Array = [];        //Arrays to store the currently active maps    private var _currentPlatformMap:Array = [];    private var _currentObjectMap:Array = [];    private var _currentLevel:uint = 0;    	  //Create blank BitmapData objects as the canvas for the game    private var _backgroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _backgroundBitmap:Bitmap       = new Bitmap(_backgroundBitmapData);    private var _foregroundBitmapData:BitmapData       = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);    private var _foregroundBitmap:Bitmap       = new Bitmap(_foregroundBitmapData);  	  	//Tile sheet		[Embed(source="../../images/tileSheet.png")]    private var TileSheet:Class;		private var _tileSheetImage:DisplayObject = new TileSheet();		private var _tileSheetBitmapData:BitmapData 		  = new BitmapData			  (			    _tileSheetImage.width, 			    _tileSheetImage.height, 			    true, 			    0			  );        //Create a TileModel to represent the cat    private var _catModel:TileModel;    private var _UIPlatformController:UIPlatformController;    private var _UIPlatformView:UIPlatformView;		  		//Create a collision Controller		private var _collisionController:TileCollisionController		 = new TileCollisionController();          private var _currentTile:uint = 0;    private var _mapRow:uint = 0;    private var _mapColumn:uint = 0;        //Status box  	private var _statusBox:StatusBox = new StatusBox;  			//Embed the XML file		[Embed(source = "../assets/xml/maps.xml",		mimeType = "application/octet-stream")]    private var XmlData:Class;    		public function MultipleXMLMaps():void		{  		  //Create the maps for the game		  //createMaps();		  createXMLMaps();		  		  //Draw the BitmapData objects			_tileSheetBitmapData.draw(_tileSheetImage);					  //Add the stage bitmaps			addChild(_backgroundBitmap);			addChild(_foregroundBitmap);						//Add the status box			addChild(_statusBox);						//Run the buildMap method to convert the			//map array data into a visual display			buildMap(_currentPlatformMap);			buildMap(_currentObjectMap);				addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}		public function createXMLMaps():void		{		  //Create the map array from the XML file		  		  //Load the XML file		  var maps:Object = new XmlData();		  		  //Cast it as an XML object		  maps = XML(maps);		  		  //Find out how many maps there are how 		  //and many rows there are in each map		  var numberOfMaps:int = maps.level.platformMap.length();		  var numberOfRows:int = maps.level.platformMap.row.length();		  var rowsPerMap:int = numberOfRows / numberOfMaps;		  		  //Load the platform maps		  		  //Create empty map arrays for each map and store them in the		  //the _platformMapContainer array		  for(var i:int = 0; i < numberOfMaps; i++)		  {		    var platformMap:Array = [];  		  _platformMapContainer.push(platformMap);		  }		  		  //Variables needed to build the maps		  var rowCounter:uint = 0;		  var mapCounter:uint = 0;		  var row:XML;		  var rowString:String;		  var rowArray:Array;		    		//Loop through each platformMap.row element  		var platformRowList:XMLList = maps.level.platformMap.row;  		for each(row in platformRowList)  		{		    //Convert the row text node into a string		    rowString = row.toString();	    		    //Convert the string into an array.		    //Commas separate each array element		    rowArray = rowString.split(",");	      	      //Push the rowArray into one of the 	      //platform map arrays	      _platformMapContainer[mapCounter].push(rowArray)	      	      //Add one to the row counter	      rowCounter++ 	      	      //If the rowCounter is divisible 	      //by 8 (the value of rowsPerMap)	      //then you know you've reached the first row of	      //the next map. Increase the mapCounter by one	      if(rowCounter % rowsPerMap == 0)	      {	        mapCounter++;	      }		  }		  		  //Load the game object maps.		  //This code is almost identical to the code above that		  //loaded the platform maps		  		  //Create empty map arrays for each map and store them in the		  //the _gameObjectMapContainer array		  for(var j:int = 0; j < numberOfMaps; j++)		  {		    var gameObjectMap:Array = [];  		  _gameObjectMapContainer.push(gameObjectMap);		  }		  		  //Reset the row and map counters		  rowCounter = 0;		  mapCounter = 0;		  		  //Loop through each row element in the 		  //game object maps		  var objectRowList:XMLList = maps.level.gameObjectMap.row;		  for each(row in objectRowList)  		{		    //Convert the row text node into a string		    rowString = row.toString();	    		    //Convert the string into an array.		    //Commas separate each array element		    rowArray = rowString.split(",");	      	      //Push the rowArray into one of the 	      //game object map arrays	      _gameObjectMapContainer[mapCounter].push(rowArray)	      	      //Add one to the row counter	      rowCounter++ 	      	      //If the rowCounter is divisible 	      //by 8 (the value of rowsPerMap)	      //then you know you've reached the first row of	      //the next map. Increase the mapCounter by one	      if(rowCounter % rowsPerMap == 0)	      {	        mapCounter++;	      }		  }		  		  //Load the names of each level		  //by looping through all the <name> elements		  //and pushing them into an array		  var nameList:XMLList = maps.level.name;		  for each (var name:XML in nameList) 		  {		    _levelNames.push(name.text());	    }	    	    //Set the current maps for the first level	    //that you want to be displayed		  _currentPlatformMap = _platformMapContainer[_currentLevel];      _currentObjectMap = _gameObjectMapContainer[_currentLevel];	  }			private function enterFrameHandler(event:Event):void		{ 		  //Update the cat's Model		  _catModel.update();		  		  //Stop the cat at the stage boundaries		  StageBoundaries.stopBitmap(_catModel, stage); 		  		  if(_catModel.yPos + _catModel.height >= stage.stageHeight)		  {		    _catModel.jumping = false;		  }		  		  //Clear the stage bitmap 		  _foregroundBitmapData.fillRect(_foregroundBitmapData.rect, 0);		  		  //Check for collisions with the platforms		  _collisionController.platformCollision		    (_catModel, _currentPlatformMap, MAX_TILE_SIZE, PLATFORM);		  		  //Check for collisions with the soft platforms		  _collisionController.softPlatformCollision		    (		      _catModel, _currentPlatformMap, 		      MAX_TILE_SIZE, SOFT_PLATFORM		    ); 		  		  //Check for a collision with the door  		  if(_currentPlatformMap[_catModel.mapRow][_catModel.mapColumn] 		    == DOOR)      {        //Add "1" to the current level         _currentLevel++;                //Optionally, loop the game levels by setting _currentLevel        //back to "0" when the last level of the game is reached   	    if(_currentLevel >= _platformMapContainer.length)  	    {  	      _currentLevel = 0;  	    }  	      	    //Use the value of _currentLevel to load the new level maps  	    _currentPlatformMap = _platformMapContainer[_currentLevel];        _currentObjectMap = _gameObjectMapContainer[_currentLevel];                //Build the maps using the usual buildMap method        buildMap(_currentPlatformMap);  			buildMap(_currentObjectMap);      }           		  //Blit the cat on the foreground bitmap		  drawGameObject(_catModel, _foregroundBitmapData);		  		  //Update status box			_statusBox.text = "MULTIPLE XML MAPS:"; 			_statusBox.text 			  += "\n" + "CURRENT LEVEL: " + _currentLevel;			_statusBox.text 			  += "\n" + "LEVEL NAME: " + _levelNames[_currentLevel];  			_statusBox.text 			  += "\n" + "TOTAL LEVELS: " + _platformMapContainer.length;  		 }		 		//Create tile Models and map them to the		//correct positions on the tile sheet		private function buildMap(map:Array):void	  {      for(var mapColumn:int = 0; mapColumn < MAP_COLUMNS; mapColumn++)      {        for(var mapRow:int = 0; mapRow < MAP_ROWS; mapRow++)        {          var currentTile:int = map[mapRow][mapColumn];                  if(currentTile > -1)          {            //Find the tile's column and row position            //on the tile sheet            var tileSheetColumn:uint               = uint(currentTile / 10);            var tileSheetRow:uint               = uint(currentTile % 10);                        switch(currentTile)            {              case CAT:                _catModel      	          = new TileModel      	          (      	            MAX_TILE_SIZE,      	            tileSheetColumn, tileSheetRow,       	            mapRow, mapColumn,       	            48, 42      	          );   	                	        //Add some gravity        	        _catModel.gravity_Vy = 0.98;  	              	        //Add the UIView and UIController        	        _UIPlatformController      	          = new UIPlatformController(_catModel);    	          _UIPlatformView    		          = new UIPlatformView    		          (_catModel, _UIPlatformController, stage);  		                	        drawGameObject(_catModel, _foregroundBitmapData);      	        break;                        case PLATFORM:                var platform:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,    	            tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE                );    	          drawGameObject(platform, _backgroundBitmapData);                break;                          case SKY:                var sky:TileModel                   = new TileModel                  (                    MAX_TILE_SIZE,    	              tileSheetColumn, tileSheetRow,       	            mapRow, mapColumn,       	            MAX_TILE_SIZE, MAX_TILE_SIZE                  );    	          drawGameObject(sky, _backgroundBitmapData);                break;                            case SOFT_PLATFORM:               var softPlatform:TileModel                 = new TileModel                (                  MAX_TILE_SIZE,                  tileSheetColumn, tileSheetRow,     	            mapRow, mapColumn,     	            MAX_TILE_SIZE, MAX_TILE_SIZE                );    	        drawGameObject(softPlatform, _backgroundBitmapData)              break;                            case DOOR:               var door:TileModel                  = new TileModel                 (                   MAX_TILE_SIZE,                   tileSheetColumn, tileSheetRow,       	           mapRow, mapColumn,       	           MAX_TILE_SIZE, MAX_TILE_SIZE                 );  	          drawGameObject(door, _backgroundBitmapData);              break;                             }         }       }     }   }				private function drawGameObject		  (		    tileModel:TileModel, 		    screen:BitmapData		  ):void		{		  var sourceRectangle:Rectangle = new Rectangle  			(  		    tileModel.tileSheetColumn * MAX_TILE_SIZE,   			  tileModel.tileSheetRow * MAX_TILE_SIZE,   			  tileModel.width,   			  tileModel.height  			);					  	  var destinationPoint:Point = new Point      (        tileModel.xPos,         tileModel.yPos      );            screen.copyPixels        (          _tileSheetBitmapData,           sourceRectangle,           destinationPoint,          null, null, true        );	  }	}}