package{  import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.events.MouseEvent;	import flash.display.DisplayObject;	import com.friendsofed.utils.*;	import com.friendsofed.gameElements.primitives.*;	import com.friendsofed.vector.*;	public class GameController 	{	  private var _gameModel:GameModel;		private var _stage:Object;				//The paddle		private var _paddleModel:RectangleModel;  	private var _MousePaddleController:MousePaddleController;  	private var _MousePaddleView:MousePaddleView;  	private var _paddleView:RectangleBlockView;  	  	//The ball  	private var _ballModel:CircleModel;  	private var _ballView:CircleBlockView;		public function GameController(model:GameModel, stage:Object):void 		{			_gameModel = model;			_stage = stage;			_stage.addEventListener(Event.ENTER_FRAME, enterFrameHandler);			createLevel();		}		public function createLevel():void		{		   //Create the paddle		  _paddleModel = new RectangleModel(150, 25);  	  _MousePaddleController   	    = new MousePaddleController(_paddleModel);  	  _MousePaddleView   	    = new MousePaddleView  	    (_paddleModel, _MousePaddleController, _stage);  	      	  _paddleView   	    = new RectangleBlockView(_paddleModel);  	    	  //Add the _paddleModel to the GameModel and the _paddleView   	  //to the GameModel's screen Sprite  	  _gameModel.paddle = _paddleModel;  	  _gameModel.screen.addChild(_paddleView);  	    	  //Position the paddle at the bottom   	  //of the stage and give it a color  	  _gameModel.paddle.setX = _stage.stageWidth * 0.5;			_gameModel.paddle.setY 			  = _stage.stageHeight - _gameModel.paddle.height * 0.5;			_gameModel.paddle.color = 0x4E4E4E;  	    	  //Create the ball  	  _ballModel = new CircleModel(15);  	  _ballView = new CircleBlockView(_ballModel);  	    	  //Add the _ballModel to the GameModel and the _ballView   	  //to the GameModel's screen Sprite  	  _gameModel.ball = _ballModel;  	  _gameModel.screen.addChild(_ballView);  	    	  //Position the ball, give it an initial velocity  	  //and set its friction and color			_gameModel.ball.setX = 275;			_gameModel.ball.setY = 250;			_gameModel.ball.vy = 5;			_gameModel.ball.vx = 3;			_gameModel.ball.friction = 1;			_gameModel.ball.color = 0xC27D96;            //Create the blocks and position them in rows and columns      //Array to store block colors  	  var blockColors:Array   	    = [0xBDCEA8, 0x90AE9A, 0x769690, 0x6C8388, 0x061737F];  	  var currentBlock:uint = 0;			for(var columns:int = 0; columns < _gameModel.COLUMNS; columns++)      {        for(var rows:int = 0; rows < _gameModel.ROWS; rows++)        {          //Create the block models          var blockModel:RectangleModel             = new RectangleModel            (_gameModel.blockWidth, _gameModel.blockHeight);                    //Position the blockModels in a grid          blockModel.setX             = columns * _gameModel.blockWidth             + _gameModel.blockWidth * 0.5;                      blockModel.setY             = rows * _gameModel.blockHeight             + _gameModel.blockHeight * 0.5;                    //Assign a random color          var color:uint             = Math.round(Math.random() * blockColors.length);          blockModel.color = blockColors[color];                    //Push the block model into the GameModel's blocks array          _gameModel.blockModels.push(blockModel);                    //Create the block views and add it to the GameModel's          //screen sprite          var blockView:RectangleBlockView             = new RectangleBlockView(blockModel);          _gameModel.blockViews.push(blockView);          _gameModel.screen.addChild(blockView);                    //Increment the currentBlock           //counter to plot the next element          currentBlock++;        }      }	  }		private function enterFrameHandler(event:Event):void		{		  _gameModel.paddle.update();		  StageBoundaries.stop(_gameModel.paddle, _stage);		  		  _gameModel.ball.update();		  StageBoundaries.bounce(_gameModel.ball, _stage);		  		  circleVsRectangle(_gameModel.ball, _gameModel.paddle);		  		  for(var i:int = 0; i < _gameModel.blockModels.length; i++)      {        circleVsRectangle          (_gameModel.ball, _gameModel.blockModels[i]);                //Remove the block if it's been hit:         //if its "visible" property has been set to false          //by the circleVsRectangle method        if(_gameModel.blockModels[i].visible == false)        {          _gameModel.screen.removeChild(_gameModel.blockViews[i]);			    _gameModel.blockViews.splice(i, 1);			    _gameModel.blockModels.splice(i, 1);			  			    //Update the score			    _gameModel.score++;		    }      }	  }	  public function circleVsRectangle	    (c1:CircleModel, r1:RectangleModel):void		{			//Vector between objects			var v0:VectorModel 			  = new VectorModel(c1.xPos, c1.yPos, r1.xPos, r1.yPos); 						//Find the voronoi region			var region:String = "";						//Is the circle above the rectangle's top edge?			if(c1.yPos < r1.yPos - r1.height * 0.5)			{			  //If it is, we need to check whether it's in the 			  //top left, top center or top right			  if(c1.xPos < r1.xPos - r1.width * 0.5)			  {			    region = "topLeft";			  }			  else if (c1.xPos > r1.xPos + r1.width * 0.5)			  {			    region = "topRight";			  }			  else			  {			    region = "topMiddle";			  }			}			//The circle isn't above the top edge, so it might be 			//below the bottom edge			else if (c1.yPos > r1.yPos + r1.height * 0.5)			{			  //If it is, we need to check whether it's in the 			  //bottom left, bottom center or bottom right			  if(c1.xPos < r1.xPos - r1.width * 0.5)			  {			    region = "bottomLeft";			  }			  else if (c1.xPos > r1.xPos + r1.width * 0.5)			  {			    region = "bottomRight";			  }			  else			  {			    region = "bottomMiddle";			  }			}			//The circle isn't above the top edge or below the bottom			//edge it must be on the left or right side			else			{			  if(c1.xPos < r1.xPos - r1.width * 0.5)			  {			    region = "leftMiddle";			  }			  else			  {			    region = "rightMiddle";			  }			}					//If the circle is the topMiddle, 			//bottomMiddle, leftMiddle or rightMiddle			//perform the standard check for overlaps as you would			//with a rectangle						if(region == "topMiddle"			|| region == "bottomMiddle"			|| region == "leftMiddle"			|| region == "rightMiddle")			{			//Check whether the projection on 			//the x axis (in this case the v0's vx) 			//is less than the combined half widths			if(Math.abs(v0.vx) < c1.width * 0.5 + r1.width * 0.5)			{			  //A collision might be ocurring! Check the other 			  //projection on the y axis (v0's vy)			  			  if(Math.abs(v0.vy) < c1.height * 0.5 + r1.height * 0.5)			  {			    //A collision has ocurred! This is good!			    			    //Find out the size of the overlap on both the X and Y axis			    var overlap_X:Number 			      = c1.width * 0.5 + r1.width * 0.5 - Math.abs(v0.vx);			    var overlap_Y:Number 			      = c1.height * 0.5 + r1.height * 0.5 - Math.abs(v0.vy);			    			    //The collision has occurred on the axis with the			    //*smallest* amount of overlap. Let's figure out which			    //axis that is			    			    if(overlap_X >=  overlap_Y)			    {			      //The collision is happening on the X axis			      //But on which side? v0's vy can tell us 			      if(v0.vy > 0)			      {			        //Collision on top			        c1.setY = c1.yPos - overlap_Y;			      }			      else			      {			        //Collision on bottom			        c1.setY = c1.yPos + overlap_Y;			      }			      			      //Plot the X axis at r1's position			      var xAxis:VectorModel 			        = new VectorModel			        (			          c1.xPos - r1.width * 0.5, 			          c1.yPos, 			          c1.xPos + r1.height * 0.5, 			          c1.yPos			        );			        			      VectorMath.bounceOnPlane(c1, xAxis, 1, 0.98); 			      			      //Set the rectangle's "visible" property to "false" if the			      //rectangle is that's being hit isn't the player's paddle.			      //This flags it to be removed from the blockModels			      //and blockViews arrays			      if(r1 != _gameModel.paddle)			      {			        r1.visible = false;			      }                     			    }			    else			    {			       			      //The collision is happening on the Y axis			      //But on which side? v0's vx can tell us 			      if(v0.vx > 0)			      {			        //Collision on left			        c1.setX = c1.xPos - overlap_X;			      }			      else			      {			        //Collision on right			        c1.setX = c1.xPos + overlap_X;			      }			      			      //Plot the y axis at r1's position			      var yAxis:VectorModel 			        = new VectorModel			        (			          c1.xPos, 			          c1.yPos - r1.height * 0.5, 			          c1.xPos, 			          c1.yPos + r1.height * 0.5			        );			        			      VectorMath.bounceOnPlane(c1, yAxis, 1, 0.98);			      //Set the rectangle's "visible" property to false if the			      //rectangle is that's being hit isn't the player's paddle.			      //This flags it to be removed from the blockModels			      //and blockViews arrays			      if(r1 != _gameModel.paddle)			      {			        r1.visible = false;			      }      			    }			  }			  else			  {			    //No collision			  }			}			else			{			  //No collision			}		}				  //The circle isn't in danger of intersecting 		  //with any of the rectangle's planes,		  //so it has to be closer to one of the four corners		  //The checkCornerCollision method 		  //does the work of the collison detection		  //It takes four arguments:		  //1. The CircleModel object		  //2. The x position of the corner		  //3. The y position of the corner		  //4. The bounce multiplier which 		  //determines the amount of "bouncines"				  if(region == "topLeft")		  {			  checkCornerCollision			    (			      c1, 			      r1.xPos - r1.width * 0.5, 			      r1.yPos - r1.height * 0.5, 			      1,			      r1			    ); 		  }		  else if(region == "topRight")		  {		    checkCornerCollision		      (		        c1, r1.xPos + r1.width * 0.5, 		        r1.yPos - r1.height * 0.5, 		        1,		        r1		      ); 		  }		  else if(region == "bottomLeft")		  {		    checkCornerCollision		      (		        c1, r1.xPos - r1.width * 0.5, 		        r1.yPos + r1.height * 0.5, 		        1,		        r1		      ); 		  }		  else if(region == "bottomRight")		  {		    checkCornerCollision		      (		        c1, 		        r1.xPos + r1.width * 0.5, 		        r1.yPos + r1.height * 0.5, 		        1,		        r1		      ); 		  }			}		//Check for collisions between the circle and the corners		//And apply the bounce effect if a collision occurs		private function checkCornerCollision		  (		    circle:CircleModel, 		    corner_X:Number, 		    corner_Y:Number, 		    bounceAmount:Number,		    r1:RectangleModel		  ):void		{		  //Vector between circle and particle			var v0:VectorModel 			  = new VectorModel			  (circle.xPos, circle.yPos, corner_X, corner_Y);   						if(v0.m < circle.radius)			{			  			  //Find the amount of overlap 				var overlap:Number = circle.radius - v0.m;                      			  circle.setX = circle.xPos - (overlap * v0.dx);				circle.setY = circle.yPos - (overlap * v0.dy);                //circle's motion vector  			var v1:VectorModel   			  = new VectorModel  			  (  			    circle.xPos,   			    circle.yPos,   			    circle.xPos + circle.vx,   			    circle.yPos + circle.vy  			  );  			                                             //Create the circle's bounce vector                          var bounce:VectorModel = VectorMath.bounce(v1, v0.ln);                //Bounce the circle        circle.vx = bounce.vx * bounceAmount;         circle.vy = bounce.vy * bounceAmount;         //Set the rectangle's "visible" property to false if the			  //rectangle is that's being hit isn't the player's paddle.			  //This flags it to be removed from the blockModels			  //and blockViews arrays			  if(r1 != _gameModel.paddle)			  {	        r1.visible = false;	      }   			}		}	}}