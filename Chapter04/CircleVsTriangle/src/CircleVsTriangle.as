package{	import flash.events.Event;  import flash.display.Sprite;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class CircleVsTriangle extends Sprite	{			//Circle  		private var _c1:CircleModel = new CircleModel(30);  		private var _UIController:UIController = new UIController(_c1);  		private var _c1_View:CircleView = new CircleView(_c1);  		private var _UIView:UIView   		  = new UIView(_c1, _UIController, stage);  		  		//Triangle  		private var _t1:TriangleModel = new TriangleModel(60, 80);  		private var _t1_View:TriangleView = new TriangleView(_t1);  		  		//Vector between shapes  		private var _v0A:VectorModel = new VectorModel();   		  		//A vector that describe's the triangle's hypotenuse   		private var _hypotenuse:VectorModel = new VectorModel();   		  		//Vector that represents the   		//projection of v0 onto the hypotenuse  		private var _v0A_P:VectorModel = new VectorModel();  		  		//Vector that represents the   		//projection of r1 onto the hypotenuse  		private var _v1_P:VectorModel = new VectorModel();  		private var _v1_P_View:VectorView   		  = new VectorView(_v1_P, "basic");						//A variable to help us test for a collision			private var _collisionSide:String = "No collision";                        		//Status box  		private var _statusBox:StatusBox = new StatusBox;				public function CircleVsTriangle():void		{ 		  //Circle			addChild(_c1_View);			_c1.setX = 350;			_c1.setY = 250;						//Triangle			addChild(_t1_View);			_t1.setX = 250;			_t1.setY = 250;						//Triangle's hyponentuse			_hypotenuse.update			  (			    _t1.xPos - _t1.width * 0.5,  		    _t1.yPos - _t1.height * 0.5,  		    _t1.xPos + _t1.width * 0.5,   		    _t1.yPos + _t1.height * 0.5  		  );						//View of the projection of the rectangle onto			//the hypotenuse's normal		  addChild(_v1_P_View);		  		  //Add the status boxes			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{ 			//Update _c1 			_c1.update();			StageBoundaries.bounce(_c1, stage);       						//Update _t1			_t1.update();			StageBoundaries.bounce(_t1, stage);			      //Vector between rectangles			_v0A.update(_c1.xPos, _c1.yPos, _t1.xPos, _t1.yPos);						//Vector between the center of the circle 			//and the hypotenuse's start point			//We need this to calculate whether the circle is within the 			//hypotenuse's voronoi region			var v0B:VectorModel 			  = new VectorModel			  (			    _c1.xPos, 			    _c1.yPos, 			    _hypotenuse.a.x, 			    _hypotenuse.a.y			  );						//Dot product that will help 			//tell us whether the circle is within			//the triangle's voronoi region			var dp1:Number = VectorMath.dotProduct(v0B, _hypotenuse);						//Find the voronoi region			var region:String = "";						//Which region is the circle in?			//First check the hypotenuse			if(dp1 < 0 			&& dp1 > -_hypotenuse.m			&& _c1.xPos > _t1.xPos - _t1.width * 0.5			&& _c1.yPos < _t1.yPos + _t1.height * 0.5)			{			  region = "hypotenuse";			}			//If it's not in the hypotenuse region,			//check the other possibilities			else			{			  //Check the top corner			  if(_c1.yPos < _t1.yPos - _t1.height * 0.5			  && dp1 > 0)			  {			    region = "topCorner";			  }			  //The circle isn't above the top edge, so it might be 			  //below the bottom edge			  else if (_c1.yPos > _t1.yPos + _t1.height * 0.5)			  {			    //If it is, we need to check whether it's in the 			    //bottom left, bottom center or bottom right			    if(_c1.xPos < _t1.xPos - _t1.width * 0.5)			    {			      region = "bottomLeftCorner";			    }			    else if(_c1.xPos > _t1.xPos + _t1.width * 0.5)			    {			      region = "bottomRightCorner";			    }			    else			    {			      region = "bottomMiddle";			    }		    }		    //The circle isn't above the top edge or below the bottom			  //edge so it must be on the left or right side			  else			  {			    if(_c1.xPos < _t1.xPos - _t1.width * 0.5)			    {			      region = "leftMiddle";			    }			    //If all the previous tests fail, then 			    //the circle must be within the wedge of space between the			    //bottom right corner and the the hypotenuse's region			    else			    {			      region = "bottomRightCorner";			    }		    }			}			  		if(region == "bottomMiddle"  		|| region == "leftMiddle"  		|| region == "hypotenuse")  		{   		  		  //Project _v0A onto the hypotenuse's normal  		  //Get the projection's vx and vy  		  var v0_P:VectorModel   		    = VectorMath.project(_v0A, _hypotenuse.ln);  		      		  _v0A_P.update  		    (  		      _hypotenuse.ln.a.x, _hypotenuse.ln.a.y,   		      _hypotenuse.ln.a.x - v0_P.vx,  		      _hypotenuse.ln.a.y - v0_P.vy  		    );  		  		    		  //A vector that represents the projected radius  		  //on the hypotenuse's normal  		  _v1_P.update  		    (  		      _hypotenuse.ln.a.x + _v0A_P.vx,  		      _hypotenuse.ln.a.y + _v0A_P.vy,   		      _hypotenuse.ln.a.x + _v0A_P.vx   		        - _hypotenuse.ln.dx * _c1.radius,  		      _hypotenuse.ln.a.y + _v0A_P.vy   		        - _hypotenuse.ln.dy * _c1.radius  		    );    		  		  //The distance between hypotenuse and the projected circle  	    var hDistance:VectorModel   	      = new VectorModel  	      (  	        _hypotenuse.ln.a.x,   	        _hypotenuse.ln.a.y,  	        _hypotenuse.ln.a.x - _v0A_P.vx - _v1_P.vx,  	        _hypotenuse.ln.a.y - _v0A_P.vy - _v1_P.vy  	      );  	    	    //The dot product that helps us figure   	    //out if the projection of the  	    //circle is overlaping the hypotenuse                                              	    var dp2:Number   	      = VectorMath.dotProduct(hDistance, _hypotenuse.ln);    	                                           			  //Check whether the projections are overlapping.			  if(Math.abs(_v0A.vx) < _c1.radius + _t1.width * 0.5)			  {			    //A collision might be ocurring! Check the other 			    //projection on the y axis (v0's vy)			  			    if(Math.abs(_v0A.vy) < _c1.radius + _t1.height * 0.5)			    {			      //Check the projection on the hypotenuse's normal			    			      if(dp2 > 0)			      {			        //A collision has ocurred			    			        //Find out the size of the overlap 			        //on both the X and Y axis			        var overlap_X:Number 			          = _c1.radius 			          + _t1.width * 0.5 			          - Math.abs(_v0A.vx);			          			        var overlap_Y:Number 			          = _c1.radius 			          + _t1.height * 0.5 			          - Math.abs(_v0A.vy);			          			        var overlap_H:Number = dp2;			    			        //The collision has occurred on the axis with the			        //*smallest* amount of overlap. Let's figure out which			        //axis that is			    			        if(overlap_X <  overlap_Y			        && overlap_X <  overlap_H)			        {			      			          //The collision is happening on the Y axis			          //But on which side? v0's vx can tell us 			          if(_v0A.vx > 0)			          {			            _collisionSide = "Left";			            _c1_View.alpha = 0.5;			            _c1.setX = _c1.xPos - overlap_X;			          }			          else			          {			            _collisionSide = "Right";			            _c1_View.alpha = 0.5;			            _c1.setX = _c1.xPos + overlap_X;			          }			          			          //Plot the y axis at _c1's position			          //and bounce the circle			          var yAxis:VectorModel 			            = new VectorModel			            (			              _c1.xPos, 			              _c1.yPos, 			              _c1.xPos, 			              _c1.yPos + _c1.height			            );			                                                			          VectorMath.bounceOnPlane(_c1, yAxis, 0.6, 0.98);                        			          }			          else if			            (overlap_Y < overlap_X && overlap_Y < overlap_H)			          {			            			          //The collision is happening on the X axis			          //But on which side? v0's vy can tell us 			        			          if(_v0A.vy > 0)			          {			            _collisionSide = "Top";			            _c1_View.alpha = 0.5;			            _c1.setY = _c1.yPos - overlap_Y;			          }			          else			          {			            _collisionSide = "Bottom";			            _c1_View.alpha = 0.5;			            _c1.setY = _c1.yPos + overlap_Y;			          }			      			          //Plot the X axis at _c1's position			          //and bounce the circle			          var xAxis:VectorModel 			            = new VectorModel			            (			              _c1.xPos, 			              _c1.yPos, 			              _c1.xPos + _c1.width, 			              _c1.yPos			            );			                                                			          VectorMath.bounceOnPlane(_c1, xAxis, 0.1, 0.98); 			        }			        else if(overlap_H < overlap_Y && overlap_H < overlap_X)			         {			          //The collision is happening on the hypotenuse			        			          _collisionSide = "Hypotenuse";			          _c1_View.alpha = 0.5;			        			          //Use the hDistance's vx and vy to correctly			          //reposition the circle			          _c1.setY = _c1.yPos + hDistance.vy;			          _c1.setX = _c1.xPos + hDistance.vx;			        			          //Bounce			          VectorMath.bounceOnPlane(_c1, _hypotenuse, 0.1, 0.98);		          }	          }			      else			      {			        _collisionSide = "No collision";			        _c1_View.alpha = 1;			      }			    }			    else			    {			      _collisionSide = "No collision";			      _c1_View.alpha = 1;			    }		    }		    else			  {			    _collisionSide = "No collision";			    _c1_View.alpha = 1;			  }		  }						if(region == "topCorner")		  {			  checkCornerCollision			    (			      _c1, 			      _t1.xPos - _t1.width * 0.5, 			      _t1.yPos - _t1.height * 0.5, 			      0.6			    ); 		  }		  else if(region == "bottomLeftCorner")		  {		    checkCornerCollision		      (		        _c1, 		        _t1.xPos - _t1.width * 0.5, 		        _t1.yPos + _t1.height * 0.5, 		        0.6		      ); 		  }		  else if(region == "bottomRightCorner")		  {		    checkCornerCollision		      (		        _c1, 		        _t1.xPos + _t1.width * 0.5, 		        _t1.yPos + _t1.height * 0.5, 		        0.6		      ); 		  }		  			//Update the status box			_statusBox.text = "CIRCLE VS TRIANGLE:";			_statusBox.text += "\n" + "COLLISION SIDE: " + _collisionSide;			_statusBox.text += "\n" + "REGION: " + region;			_statusBox.text 			  += "\n" + "DP1: " + Math.round(dp1 * 1000) / 1000;			_statusBox.text 			  += "\n" + "HYPOTENUSE.M: " + _hypotenuse.m;		}		public function checkCornerCollision		  (		    circle:CircleModel, 		    corner_X:Number, 		    corner_Y:Number, 		    bounceAmount:Number		  ):void		{		  //Vector between circle and particle			var v0:VectorModel 			  = new VectorModel			  (			    circle.xPos, 			    circle.yPos, 			    corner_X, 			    corner_Y			  );   						if(v0.m < circle.radius)			{			  			  //Find the amount of overlap 				var overlap:Number = circle.radius - v0.m;                      			  circle.setX = circle.xPos - (overlap * v0.dx);				circle.setY = circle.yPos - (overlap * v0.dy);                //circle's motion vector  			var v1:VectorModel   			  = new VectorModel  			  (  			    circle.xPos,   			    circle.yPos,   			    circle.xPos + circle.vx,   			    circle.yPos + circle.vy  			  );  			                                             //Create the circle's bounce vector                          var bounce:VectorModel = VectorMath.bounce(v1, v0.ln);                //Bounce the circle        circle.vx = bounce.vx * bounceAmount;         circle.vy = bounce.vy * bounceAmount;			}		}	}}