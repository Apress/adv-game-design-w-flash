package{	import flash.events.Event;  import flash.display.Sprite;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class RectangleVsRectangle extends Sprite	{			//Rectangle 1 (player's rectangle)  		private var _r1:RectangleModel   		  = new RectangleModel(60, 45);  		private var _UIController:UIController   		  = new UIController(_r1);  		private var _r1_View:RectangleView   		  = new RectangleView(_r1);  		private var _UIView:UIView   		  = new UIView(_r1, _UIController, stage);  		  		//Rectangle 2  		private var _r2:RectangleModel = new RectangleModel(60, 45);  		private var _r2_View:RectangleView = new RectangleView(_r2);  		  		//Vector between rectangles  		private var _v0:VectorModel = new VectorModel();   		private var _v0_View:VectorView = new VectorView(_v0, "basic"); 						//A variable to help us test for a collision			private var _collisionSide:String = "No collision";                        		//Status box to display the result of the projection  		private var _statusBox:StatusBox = new StatusBox;  						public function RectangleVsRectangle():void		{ 		  //Rectangle 1			addChild(_r1_View);			_r1.setX = 300;			_r1.setY = 200;						//Rectangle 2			addChild(_r2_View);			_r2.setX = 200;			_r2.setY = 200;						//Add the vector views			addChild(_v0_View);		  		  //Add the status box			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{ 			//Update _r1 (player's rectangle)			_r1.update();			StageBoundaries.bounce(_r1, stage);       						//Update _r2			_r2.update();			StageBoundaries.bounce(_r2, stage);			      //Vector between rectangles			_v0.update(_r1.xPos, _r1.yPos, _r2.xPos, _r2.yPos); 						//Check whether the projection on the 			//x axis (in this case the v0's vx) 			//is less than the combined half widths			if(Math.abs(_v0.vx) < _r1.width * 0.5 + _r2.width * 0.5)			{			  //A collision might be occurring! Check the other 			  //projection on the y axis (v0's vy)			  			  if(Math.abs(_v0.vy) < _r1.height * 0.5 + _r2.height * 0.5)			  {			    //A collision has ocurred! This is good!			    			    //Find out the size of the overlap on both the X and Y axes			    var overlap_X:Number 			      = _r1.width * 0.5 			      + _r2.width * 0.5 			      - Math.abs(_v0.vx);			      			    var overlap_Y:Number 			      = _r1.height * 0.5 			      + _r2.height * 0.5 			      - Math.abs(_v0.vy);			    			    //The collision has occurred on the axis with the			    //*smallest* amount of overlap. Let's figure out which			    //axis that is			    			    if(overlap_X >=  overlap_Y)			    {			      //The collision is happening on the X axis			      //But on which side? _v0's vy can tell us 			      if(_v0.vy > 0)			      {			        _collisionSide = "Top";			        			        //Move the rectangle out of the collision			        _r1.setY = _r1.yPos - overlap_Y;			      }			      else			      {			        _collisionSide = "Bottom";			        			        //Move the rectangle out of the collision			        _r1.setY = _r1.yPos + overlap_Y;			      }			      			      //The rectangle needs a vector to bounce against			      //Plot the X axis at r1's position			      var xAxis:VectorModel 			        = new VectorModel			        (			          _r1.xPos - _r2.width * 0.5, 			          _r1.yPos, 			          _r1.xPos + _r2.height * 0.5, 			          _r1.yPos			        );                                     			      			      //Bounce the rectangle using the bounceOnPlane method			      bounceOnPlane(_r1, xAxis, 0.1, 0.98);                                         			    }			    else			    {			      //The collision is happening on the Y axis			      //But on which side? _v0's vx can tell us 			      if(_v0.vx > 0)			      {			        _collisionSide = "Left";			        			        //Move the rectangle out of the collision			        _r1.setX = _r1.xPos - overlap_X;			      }			      else			      {			        _collisionSide = "Right";			        			        //Move the rectangle out of the collision			        _r1.setX = _r1.xPos + overlap_X;			      }			      			      //The rectangle needs a vector to bounce against			      //Plot the y axis at r1's position			      var yAxis:VectorModel 			        = new VectorModel			        (			          _r1.xPos, 			          _r1.yPos - _r2.height * 0.5, 			          _r1.xPos, 			          _r1.yPos + _r2.height * 0.5			        ); 			                                              			      //Bounce the rectangle using the bounceOnPlane method                                                                             			      bounceOnPlane(_r1, yAxis, 0.1, 0.98); 			    }			  }			  else			  {			    _collisionSide = "No collision";			  }			}			else			{			  _collisionSide = "No collision";			}						//Plot the graphs that compare the projections to			//the combined half widths and heights						graphics.clear();			graphics.lineStyle(2);						//Display projection on x axis			graphics.moveTo(_r2.xPos, 280);			graphics.lineTo(_r2.xPos + Math.abs(_v0.vx), 280);						//Display combined half widths			graphics.lineStyle(2, 0x75993F);			graphics.moveTo(_r2.xPos, 285);			graphics.lineTo			  (_r2.xPos + _r1.width * 0.5 + _r2.width * 0.5, 285);						//Display projection on y axis			graphics.lineStyle(2);			graphics.moveTo(350, _r2.yPos);			graphics.lineTo(350, _r2.yPos - Math.abs(_v0.vy));						//Display combined half heights			graphics.lineStyle(2, 0x75993F);			graphics.moveTo(355, _r2.yPos);			graphics.lineTo			  (355, _r2.yPos - _r1.height * 0.5 - _r2.height * 0.5);						//Update status box			_statusBox.text = "RECTANGLE VS RECTANGLE:";			_statusBox.text += "\n" + "COLLISION SIDE: " + _collisionSide;			_statusBox.text 			  += "\n" + "V0.DX: " + Math.round(_v0.dx * 1000) / 1000;			_statusBox.text 			  += "\n" + "V0.DY: " + Math.round(_v0.dy * 1000) / 1000;			_statusBox.text += "\n" + "V0.VX: " + Math.round(_v0.vx);			_statusBox.text += "\n" + "V0.VY: " + Math.round(_v0.vy);			_statusBox.text 			  += "\n" + "HALF WIDTHS: " 			  + Math.round(_r1.width * 0.5  +  _r2.width * 0.5);			_statusBox.text 			  += "\n" + "HALF HEIGHTS: " 			  + Math.round(_r1.height * 0.5  +  _r2.height * 0.5);		}				//Use the bounceOnPlane method to create 		//bounce and friction for the verlet object.		//It takes four arguments: 		//1. The verlet model		//2. The vector that you want to bounce it against		//3. The bounce multiplier, for the amount of "bounciness"		//4. The friction multiplier, for the amount 		//of surface friction between objects				public function bounceOnPlane		  (		    verletModel:AVerletModel, 		    plane:VectorModel, 		    bounce:Number, 		    friction:Number		  ):void		{		  //The model's movement vector		  var v1:VectorModel 		    = new VectorModel		    (		      verletModel.xPos, 		      verletModel.yPos,   			  verletModel.xPos + verletModel.vx,   			  verletModel.yPos + verletModel.vy  			);  			  		//Find the projection vectors      var p1:VectorModel = VectorMath.project(v1, plane);      var p2:VectorModel = VectorMath.project(v1, plane.ln);              //Calculate the bounce vector      var bounce_Vx:Number = p2.vx * -1;      var bounce_Vy:Number = p2.vy * -1;              //Calculate the friction vector      var friction_Vx:Number = p1.vx;      var friction_Vy:Number = p1.vy;                  verletModel.vx         = (bounce_Vx * bounce) + (friction_Vx * friction);      verletModel.vy         = (bounce_Vy * bounce) + (friction_Vy * friction);	                                   		}	}}