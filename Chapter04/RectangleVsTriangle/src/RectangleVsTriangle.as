package{	import flash.events.Event;  import flash.display.Sprite;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class RectangleVsTriangle extends Sprite	{			//Rectangle (player's rectangle)  		private var _r1:RectangleModel   		  = new RectangleModel(60, 60);  		private var _UIController:UIController   		  = new UIController(_r1);  		private var _r1_View:RectangleView   		  = new RectangleView(_r1);  		private var _UIView:UIView   		  = new UIView(_r1, _UIController, stage);  		  		//Triangle  		private var _t1:TriangleModel = new TriangleModel(60, 80);  		private var _t1_View:TriangleView = new TriangleView(_t1);  		  		//Vector between shapes  		private var _v0:VectorModel = new VectorModel();   		//private var _v0_View:VectorView   		//  = new VectorView(_v0, "basic");  		  		//A vector that describe's the triangle's hypotenuse   		private var _hypotenuse:VectorModel = new VectorModel();   		  		//Vector that represents the   		//projection of v0 onto the hypotenuse  		private var _v0_P:VectorModel = new VectorModel();  		//private var _v0_P_View:VectorView   		//  = new VectorView(_v0_P, "basic");  		  		//Vector that represents the   		//projection of r1 onto the hypotenuse  		private var _r1_P:VectorModel   		  = new VectorModel();  		private var _r1_P_View:VectorView   		  = new VectorView(_r1_P, "basic");						//A variable to help us test for a collision			private var _collisionSide:String = "No collision";                        		//Status box to display the result of the projection  		private var _statusBox:StatusBox = new StatusBox;				public function RectangleVsTriangle():void		{ 		  //Rectangle			addChild(_r1_View);			_r1.setX = 350;			_r1.setY = 250;						//Triangle			addChild(_t1_View);			_t1.setX = 250;			_t1.setY = 250;						//Triangle's hyponentuse			_hypotenuse.update			  (			    _t1.xPos - _t1.width * 0.5,  		    _t1.yPos - _t1.height * 0.5,  		    _t1.xPos - _t1.width * 0.5 +  _t1.width,   		    _t1.yPos - _t1.height * 0.5 + _t1.height  		  );						//View of the projection of the rectangle onto			//the hypotenuse's normal		  addChild(_r1_P_View);		  //addChild(_v0_P_View);		  		  //Add the status boxes			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{  			//Update _r1 (player's rectangle)			_r1.update();			StageBoundaries.bounce(_r1, stage);       						//Update _t1			_t1.update();			StageBoundaries.bounce(_t1, stage);			      //Vector between the rectangle and the triangle			_v0.update(_r1.xPos, _r1.yPos, _t1.xPos, _t1.yPos);  		  		//Project _v0 onto the hypotenuse's normal  		//Get the projection's vx and vy  		var v0_P:VectorModel = VectorMath.project(_v0, _hypotenuse.ln)  		_v0_P.update  		  (  		    _hypotenuse.ln.a.x,   		    _hypotenuse.ln.a.y,   		    _hypotenuse.ln.a.x - v0_P.vx,  		    _hypotenuse.ln.a.y - v0_P.vy  		  );  		  		//Project r1 onto the hypotenuse's normal  		//Plot each side of the rectangle as vectors   		//(it's height and width, or, in this cases   		//half width and half height).  		//Then project those vectors onto the hypotenuse's normal.  		//When you combine the projected height   		//and width, you have a perfect 1 dimensional  		//"shadow" of the two dimensional   		//shape on the hypotenuse's normal  		var r1_W:VectorModel   		  = new VectorModel(0,0,0,0, _r1.width * 0.5, 0);  		var r1_Wp:VectorModel   		  = VectorMath.project(r1_W, _hypotenuse.ln);  		var r1_H:VectorModel   		  = new VectorModel(0,0,0,0, 0, _r1.height * 0.5);  		var r1_Hp:VectorModel   		  = VectorMath.project(r1_H, _hypotenuse.ln);  		  		//A vector that represents the projected shape  		//on the hypotenuse's normal  		_r1_P.update  		  (  		    _hypotenuse.ln.a.x + _v0_P.vx,  		    _hypotenuse.ln.a.y + _v0_P.vy,   		    _hypotenuse.ln.a.x + _v0_P.vx - (r1_Wp.vx - r1_Hp.vx),  		    _hypotenuse.ln.a.y + _v0_P.vy - (r1_Wp.vy - r1_Hp.vy)  		  );    		  		//The distance between the hypotenuse   		//and the projected rectangle  	  var hDistance:VectorModel   	    = new VectorModel  	    (  	      _hypotenuse.ln.a.x,   	      _hypotenuse.ln.a.y,  	      _hypotenuse.ln.a.x - _v0_P.vx - _r1_P.vx,  	      _hypotenuse.ln.a.y - _v0_P.vy - _r1_P.vy  	    );  	    	  //The dot product that helps us figure out   	  //if the projection of the  	  //rectangle is overlaping the hypotenuse                                              	  var dp:Number   	    = VectorMath.dotProduct(hDistance, _hypotenuse.ln);    	                                           			//Check whether the projections are overlapping on the x axis			if(Math.abs(_v0.vx) < _r1.width * 0.5 + _t1.width * 0.5)			{			  //A collision might be ocurring! Check the other 			  //projection on the y axis (v0's vy)			  			  if(Math.abs(_v0.vy) < _r1.height * 0.5 + _t1.height * 0.5)			  {			    //Check the projection on the hypotenuse's normal					    if(dp > 0)			    {			      //A collision has occurred! This is good!			    			      //Find out the size of the overlap 			      //on both the X, Y and hypotenuse axes			      var overlap_X:Number 			        = _r1.width * 0.5 			        + _t1.width * 0.5 			        - Math.abs(_v0.vx);			        			      var overlap_Y:Number 			        = _r1.height * 0.5 			        + _t1.height * 0.5 			        - Math.abs(_v0.vy);			        			      var overlap_H:Number = Math.abs(dp);			    			      //The collision has occurred on the axis with the			      //*smallest* amount of overlap. Let's figure out which			      //axis that is			    			      if(overlap_X <  overlap_Y			      && overlap_X <  overlap_H)			      {			      			        //The collision is happening on the Y axis			        //But on which side? v0's vx can tell us 			        if(_v0.vx > 0)			        {			          _collisionSide = "Left";			          _r1_View.alpha = 0.5;			          _r1.setX = _r1.xPos - overlap_X;			        }			        else			        {			          _collisionSide = "Right";			          _r1_View.alpha = 0.5;			          _r1.setX = _r1.xPos + overlap_X;			        }			        //Plot the y axis at r1's position			        //and bounce the rectangle			        var yAxis:VectorModel 			          = new VectorModel			          (			            _r1.xPos, 			            _r1.yPos, 			            _r1.xPos, 			            _r1.yPos + _r1.height			          );			                                                			        VectorMath.bounceOnPlane(_r1, yAxis, 0.6, 0.98);                        			      }			      else if(overlap_Y < overlap_X && overlap_Y < overlap_H)			      {			        //The collision is happening on the X axis			        //But on which side? v0's vy can tell us 			        			        if(_v0.vy > 0)			        {			          _collisionSide = "Top";			          _r1_View.alpha = 0.5;			          _r1.setY = _r1.yPos - overlap_Y;			        }			        else			        {			          _collisionSide = "Bottom";			          _r1_View.alpha = 0.5;			          _r1.setY = _r1.yPos + overlap_Y;			        }			      			        //Plot the X axis at r1's position			        //and bounce the rectangle			        var xAxis:VectorModel 			          = new VectorModel			          (			            _r1.xPos, 			            _r1.yPos, 			            _r1.xPos + _r1.width, 			            _r1.yPos			          );			                                                			        VectorMath.bounceOnPlane(_r1, xAxis, 0.1, 0.98); 			      }			      else if(overlap_H < overlap_Y && overlap_H < overlap_X)			      {			        //The collision is happening on the hypotenuse			        _collisionSide = "Hypotenuse";			        _r1_View.alpha = 0.5;			        			        //Use the hDistance's vx and vy to correctly			        //reposition the rectangle			        _r1.setY = _r1.yPos + hDistance.vy;			        _r1.setX = _r1.xPos + hDistance.vx;			        			        //Bounce			        VectorMath.bounceOnPlane(_r1, _hypotenuse, 0.1, 0.98);		        }	        }			    else			    {			      _collisionSide = "No collision";			      _r1_View.alpha = 1;			    }			  }			  else			  {			    _collisionSide = "No collision";			    _r1_View.alpha = 1;			  }		  }		  else			{			  _collisionSide = "No collision";			  _r1_View.alpha = 1;			}						//Update the status box			_statusBox.text = "RECTANGLE VS TRIANGLE:";			_statusBox.text += "\n" + "COLLISION SIDE: " + _collisionSide;			_statusBox.text += "\n" + "OVERLAP X: " + Math.round(overlap_X);			_statusBox.text += "\n" + "OVERLAP Y: " + Math.round(overlap_Y);			_statusBox.text += "\n" + "OVERLAP H: " + Math.round(overlap_H);			_statusBox.text 			  += "\n" + "HDISTANCE.M: " + Math.round(hDistance.m);			_statusBox.text 			  += "\n" + "HDISTANCE.VX: " + Math.round(hDistance.vx);			_statusBox.text 			  += "\n" + "HDISTANCE.VY: " + Math.round(hDistance.vy);			_statusBox.text += "\n" + "DP: " + Math.round(dp * 1000) / 1000;		}	}}