package{	import flash.events.Event;  import flash.display.Sprite;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400", backgroundColor="#FFFFFF", frameRate="60")]  	public class CircleVsRectangle extends Sprite	{			//Circle  		private var _c1:CircleModel = new CircleModel(30);  		private var _UIController:UIController = new UIController(_c1);  		private var _c1_View:CircleView = new CircleView(_c1);  		private var _UIView:UIView   		  = new UIView(_c1, _UIController, stage);  		  		//Rectangle  		private var _r1:RectangleModel = new RectangleModel(60, 45);  		private var _r1_View:RectangleView = new RectangleView(_r1);  		  		//Vector between shapes  		private var _v0:VectorModel = new VectorModel(); 						//A variable to help us test for a collision			private var _collisionSide:String = "No collision";                        		//Status box  		private var _statusBox:StatusBox = new StatusBox;  						public function CircleVsRectangle():void		{ 		  //Circle			addChild(_c1_View);			_c1.setX = 300;			_c1.setY = 200;						//Rectangle 2			addChild(_r1_View);			_r1.setX = 200;			_r1.setY = 200;		  		  //Add the status box			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{ 			//Update _c1 (player's circle)			_c1.update();			StageBoundaries.bounce(_c1, stage);       						//Update _r1			_r1.update();			StageBoundaries.bounce(_r1, stage);			      //Vector between shapes			_v0.update(_c1.xPos, _c1.yPos, _r1.xPos, _r1.yPos); 						//Find the voronoi region			var region:String = "";						//Is the circle above the rectangle's top edge?			if(_c1.yPos < _r1.yPos - _r1.height * 0.5)			{			  //If it is, we need to check whether it's in the 			  //top left, top center or top right			  if(_c1.xPos < _r1.xPos - _r1.width * 0.5)			  {			    region = "topLeft";			  }			  else if (_c1.xPos > _r1.xPos + _r1.width * 0.5)			  {			    region = "topRight";			  }			  else			  {			    region = "topMiddle";			  }			}			//The circle isn't above the top edge, so it might be 			//below the bottom edge			else if (_c1.yPos > _r1.yPos + _r1.height * 0.5)			{			  //If it is, we need to check whether it's in the 			  //bottom left, bottom center or bottom right			  if(_c1.xPos < _r1.xPos - _r1.width * 0.5)			  {			    region = "bottomLeft";			  }			  else if (_c1.xPos > _r1.xPos + _r1.width * 0.5)			  {			    region = "bottomRight";			  }			  else			  {			    region = "bottomMiddle";			  }			}			//The circle isn't above the top edge or below the bottom			//edge so it must be on the left or right side			else			{			  if(_c1.xPos < _r1.xPos - _r1.width * 0.5)			  {			    region = "leftMiddle";			  }			  else			  {			    region = "rightMiddle";			  }			}					//If the circle is in the topMiddle, 			//bottomMiddle, leftMiddle or rightMiddle			//perform the standard check for overlaps as you would			//with a rectangle						if(region == "topMiddle"			|| region == "bottomMiddle"			|| region == "leftMiddle"			|| region == "rightMiddle")			{			//Check whether the projection on 			//the x axis (in this case the v0's vx) 			//is less than the combined half widths			if(Math.abs(_v0.vx) < _c1.width * 0.5 + _r1.width * 0.5)			{			  //A collision might be occurring! Check the other 			  //projection on the y axis (v0's vy)			  			  if(Math.abs(_v0.vy) < _c1.height * 0.5 + _r1.height * 0.5)			  {			    //A collision has occurred			    			    //Find out the size of the overlap on both the X and Y axis			    var overlap_X:Number 			      = _c1.width * 0.5 			      + _r1.width * 0.5 			      - Math.abs(_v0.vx);			      			    var overlap_Y:Number 			      = _c1.height * 0.5 			      + _r1.height * 0.5 			      - Math.abs(_v0.vy);			    			    //The collision has occurred on the axis with the			    //*smallest* amount of overlap. Let's figure out which			    //axis that is			    			    if(overlap_X >=  overlap_Y)			    {			      //The collision is happening on the X axis			      //But on which side? v0's vy can tell us 			      if(_v0.vy > 0)			      {			        _collisionSide = "Top";			        _c1.setY = _c1.yPos - overlap_Y;			      }			      else			      {			        _collisionSide = "Bottom";			        _c1.setY = _c1.yPos + overlap_Y;			      }			      			      //Plot the X axis at r1's position			      var xAxis:VectorModel 			        = new VectorModel			        (			          _c1.xPos - _r1.width * 0.5, 			          _c1.yPos, 			          _c1.xPos + _r1.height * 0.5, 			          _c1.yPos			        );			        			      VectorMath.bounceOnPlane(_c1, xAxis, 0.1, 0.98);                                         			    }			    else			    {			       			      //The collision is happening on the Y axis			      //But on which side? v0's vx can tell us 			      if(_v0.vx > 0)			      {			        _collisionSide = "Left";			        _c1.setX = _c1.xPos - overlap_X;			      }			      else			      {			        _collisionSide = "Right";			        _c1.setX = _c1.xPos + overlap_X;			      }			      			      //Plot the y axis at r1's position			      var yAxis:VectorModel 			        = new VectorModel			        (			          _c1.xPos, 			          _c1.yPos - _r1.height * 0.5, 			          _c1.xPos, 			          _c1.yPos + _r1.height * 0.5			        );			        			      VectorMath.bounceOnPlane(_c1, yAxis, 0.1, 0.98); 			    }			  }			  else			  {			    _collisionSide = "No collision";			  }			}			else			{			  _collisionSide = "No collision";			}		}				//The circle isn't in danger of intersecting 		//with any of the rectangle's planes,		//so it has to be closer to one of the four corners		//The checkCornerCollision method does the 		//work of the collision detection		//It takes four arguments:		//1. The CircleModel object		//2. The x position of the corner		//3. The y position of the corner		//4. The bounce multiplier which 		//determines the amount of "bouncines"				if(region == "topLeft")		{			checkCornerCollision			  (			    _c1, 			    _r1.xPos - _r1.width * 0.5, 			    _r1.yPos - _r1.height * 0.5, 			    0.6			  ); 		}		else if(region == "topRight")		{		  checkCornerCollision		    (		      _c1, 		      _r1.xPos + _r1.width * 0.5, 		      _r1.yPos - _r1.height * 0.5, 		      0.6		    ); 		}		else if(region == "bottomLeft")		{		  checkCornerCollision		    (		      _c1, 		      _r1.xPos - _r1.width * 0.5, 		      _r1.yPos + _r1.height * 0.5, 		      0.6		    ); 		}		else if(region == "bottomRight")		{		  checkCornerCollision		    (		      _c1, 		      _r1.xPos + _r1.width * 0.5, 		      _r1.yPos + _r1.height * 0.5, 		      0.6		    ); 		}						//Update status box			_statusBox.text = "CIRCLE VS RECTANGLE:";			_statusBox.text += "\n" + "REGION: " + region;			_statusBox.text += "\n" + "COLLISION SIDE: " + _collisionSide;		}				//Check for collisions between the circle and the corners		//And apply the bounce effect if a collision occurs		public function checkCornerCollision		  (		    circle:CircleModel, 		    corner_X:Number, 		    corner_Y:Number, 		    bounceAmount:Number		  ):void		{		  //Vector between circle and particle			var v0:VectorModel 			  = new VectorModel			  (			    circle.xPos, 			    circle.yPos, 			    corner_X, 			    corner_Y			  );   						if(v0.m < circle.radius)			{			  			  //Find the amount of overlap 				var overlap:Number = circle.radius - v0.m;                      			  circle.setX = circle.xPos - (overlap * v0.dx);				circle.setY = circle.yPos - (overlap * v0.dy);                //circle's motion vector  			var v1:VectorModel   			  = new VectorModel  			  (  			    circle.xPos,   			    circle.yPos,   			    circle.xPos + circle.vx,   			    circle.yPos + circle.vy  			  );  			                                             //Create the circle's bounce vector                          var bounce:VectorModel = VectorMath.bounce(v1, v0.ln);                //Bounce the circle        circle.vx = bounce.vx * bounceAmount;         circle.vy = bounce.vy * bounceAmount;			}		}	}}