package planet{	import flash.display.Shape;	import flash.display.Sprite;	import flash.display.DisplayObject;	import flash.filters.*;	import flash.events.Event;		//Steps to map a bitmap on an object at compile time:		//1. Import these classes	import flash.display.BitmapData;  import flash.geom.Matrix;	public class Planet extends Sprite	{		private var _radius:uint;		private var _color:uint;		private var _rotation:uint;        //2. Embed the image. Use a relative path.    //Create a class to store the image    [Embed(source="../../assets/images/phobos.jpg")]    private var PlanetImage:Class;				public function Planet(size:uint = 100, color:uint = 0xFFFF00, rotation:uint = 0)		{			this._radius = size;			this._color = color;			this._rotation = rotation;						addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}		private function onAddedToStage(event:Event):void		{			drawPlanet();			addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}		private function onRemovedFromStage(event:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}		private function drawPlanet():void		{		  //3. Create a new instance of the PlanetImage class      var planetImage:DisplayObject = new PlanetImage();		  			//4. Create a BitmapData object to store the image			var image:BitmapData = new BitmapData(planetImage.width, planetImage.height, false);  						//5. Draw the image, and create a new Matrix as a parameter that will accept a rotated image      image.draw(planetImage, new Matrix());            			//6a. Optionally create a Matrix to scale (or optionally rotate) the image      var matrix:Matrix = new Matrix();            //6b. Find the correct scale for the image based on the size of the planet			var scale:Number = ((_radius * 2) / planetImage.width);						//6c. Adjust the scale by 20% so that the image margins			//are slightly cropped			var adjustedScale:Number = scale * 1.2;						//6d. apply the scale amount to the matrix			matrix.scale(adjustedScale, adjustedScale);						//6e.Center the bitmap so that its mid point is 0,0			matrix.translate(-_radius, -_radius);						//6f. Rotate the bitmap 280 degrees (the value of _rotation)			matrix.rotate(_rotation * Math.PI / 180);						//7. Draw the planet			var planetShape:Shape = new Shape();						//Use a beginBitmapFill function to draw the bitmap onto the shape			//The "true" parameter refers to whether the bitmap should be tiled			//or just drawn once			planetShape.graphics.beginBitmapFill(image, matrix, true);			planetShape.graphics.drawCircle(0, 0, _radius);			planetShape.graphics.endFill();			addChild(planetShape);						//8. Add a bevel and drop shadow filter to the planet			var planetFilters:Array = new Array();			planetFilters = planetShape.filters;			planetFilters.push(new BevelFilter(4, 135, 0xFFFFFF, 0.50, 0x000000, 0.50, 4, 4));			planetFilters.push(new DropShadowFilter(4, 135, 0x000000, 0.35, 4, 4));			planetShape.filters = planetFilters;		}				//radius getter		public function get radius():uint		{			return _radius;		}	}}