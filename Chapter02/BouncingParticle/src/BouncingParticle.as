package{	import flash.events.Event;  import flash.display.Sprite;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.vector.*;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class BouncingParticle extends Sprite	{			//Particle  		private var _particleModel:ParticleModel   		  = new ParticleModel();  		private var _particleView:ParticleView   		  = new ParticleView(_particleModel);  		//Drag handles  		private var _handle1:DragHandle = new DragHandle();  		private var _handle2:DragHandle = new DragHandle();  		//We need 3 vectors:  		//A. Vector between the particle and v2's start point  		private var _v1:VectorModel = new VectorModel();  		//B. Vector for the drag handles  		private var _v2:VectorModel   		  = new VectorModel();  		private var _v2View:VectorView   		  = new VectorView(_v2, "basic", 1);  		//C. Vector between the first drag handle and the particle  		private var _v3:VectorModel = new VectorModel();  		//Status box to display the result of the projection  		private var _statusBox:StatusBox;  		  		//Variable to track the side of the line the particle is on  		private var _lineSide:String = "";				public function BouncingParticle():void		{			//Add the drag handles to the stage		  addChild(_handle1);		  _handle1.x = 100;		  _handle1.y = 250;		  		  addChild(_handle2);		  _handle2.x = 400;		  _handle2.y = 300;		  		  //Add the particle view			addChild(_particleView);			_particleModel.setX = 150;			_particleModel.setY = 150;			_particleModel.friction = 1;			_particleModel.gravity_Vy = 0.1;		  		  //Add vector views			addChild(_v2View);						//Add the status box that displays the dot product			_statusBox = new StatusBox();			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				private function enterFrameHandler(event:Event):void		{ 		  //Update the particle model			_particleModel.update();			StageBoundaries.wrap(_particleModel, stage);       					  //v1: the particle's movement vector			_v1.update			  (			    _particleModel.xPos, 			    _particleModel.yPos, 			    (_particleModel.xPos + _particleModel.vx), 			    (_particleModel.yPos + _particleModel.vy)			  );			    	          		  //v2: the drag handle vector      _v2.update(_handle1.x, _handle1.y, _handle2.x, _handle2.y);                       						//v3: the vector between the particle and v2		  _v3.update		    (		      _particleModel.xPos, 		      _particleModel.yPos, 		      _handle1.x, 		      _handle1.y		    );         		          		  //The dot product that tells you whether the particle is within		  //the scope of the line's magnitude		  var dp1:Number = VectorMath.dotProduct(_v3, _v2);		  		  //The dotproduct that tells you which side of the line		  //the particle is on		  var dp2:Number = VectorMath.dotProduct(_v3, _v2.ln);		  		  //If the particle is within the scope of the line's magnitude		  //then set its line side to left or right      if(dp1 > -_v2.m && dp1 < 0 )      {        if(_lineSide == "")        {          if(dp2 < 0 )          {            _lineSide = "left";          }             else          {            _lineSide = "right";          }        }      }      else      {        //If the particle is not within the line's         //scope (such as rounding        //a corner) clear the _lineSide variable.        _lineSide = "";      }            //Reset the _lineSide variable if the particle has wrapped 	    //around the edges of the stage	    if(_particleModel.yPos > stage.stageHeight	    || _particleModel.yPos < 0	    || _particleModel.xPos < 0	    || _particleModel.xPos > stage.stageWidth)  	  {  	    _lineSide = "";  	  }           //Create an environmental boundary based on whether      //the particle has collided from the right or left      if(dp2 > 0 && _lineSide == "left"      || dp2 < 0 && _lineSide == "right")      {          //Create the collision vector        var collisionForce_Vx:Number = _v1.dx * Math.abs(dp2);        var collisionForce_Vy:Number = _v1.dy * Math.abs(dp2);                //Move the particle out of the collision        _particleModel.setX           = _particleModel.xPos           - collisionForce_Vx;	                   _particleModel.setY           = _particleModel.yPos           - collisionForce_Vy          - _particleModel.gravity_Vy;				        //Find the projection vectors        var p1:VectorModel = VectorMath.project(_v1, _v2);        var p2:VectorModel = VectorMath.project(_v1, _v2.ln);                //Calculate the bounce vector        var bounce_Vx:Number = p2.vx * -1;        var bounce_Vy:Number = p2.vy * -1;                //Calculate the friction vector        var friction_Vx:Number = p1.vx;        var friction_Vy:Number = p1.vy;                //Apply bounce and friction to the velocity        _particleModel.vx = (bounce_Vx * 0.6) + (friction_Vx * 0.98);        _particleModel.vy = (bounce_Vy * 0.6) + (friction_Vy * 0.98);	    }	      	  			//Display the result in a status box						_statusBox.text = "BOUNCE, FRICTION, GRAVITY:";			_statusBox.text 			  += "\n" + "DP1: " + Math.round(dp1 * 1000) / 1000;			_statusBox.text 			  += "\n" + "V2.M: " + Math.round(_v2.m * 1000) / 1000;			_statusBox.text 			  += "\n" + "DP2: " + Math.round(dp2 * 1000) / 1000;			_statusBox.text 			  += "\n" + "V1.M: " + Math.round(_v1.m * 1000) / 1000;			_statusBox.text 			  += "\n" + "LINE SIDE: " + _lineSide;					}	}}