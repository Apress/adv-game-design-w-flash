package{	import flash.events.Event;  import flash.display.*;  import flash.geom.Point;  import flash.geom.Rectangle;  import flash.geom.Matrix;  import com.friendsofed.utils.*;  import com.friendsofed.gameElements.lunarLander.*;  import com.friendsofed.gameElements.turret.*;  import com.friendsofed.gameElements.primitives.*;  import com.friendsofed.gameElements.effects.*;  import com.friendsofed.vector.*;    //Classes needed to play sounds  import flash.media.Sound;  import flash.media.SoundChannel;  import flash.media.SoundTransform;  [SWF(width="550", height="400",   backgroundColor="#FFFFFF", frameRate="60")]  	public class UsingSounds extends Sprite	{	  	  //Embed and create the sounds:        //Laser gun    [Embed(source="../assets/sounds/laserGun.mp3")]    private var LaserGun:Class;    private var _laserGun:Sound = new LaserGun();    private var _laserGunChannel:SoundChannel       = new SoundChannel();        //Explosion    [Embed(source="../assets/sounds/bigExplosion.mp3")]    private var Explosion:Class;    private var _explosion:Sound = new Explosion();    private var _explosionChannel:SoundChannel       = new SoundChannel();          //Music    [Embed(source="../assets/sounds/music.mp3")]    private var Music:Class;    //Create the _music sound from the Music class    private var _music:Sound = new Music();    private var _musicChannel:SoundChannel = new SoundChannel();         //Additional sound properties      private var _volume:Number = 3;    private var _explosionPan:Number = 0;    private var _bulletPan:Number = 0;     private var _halfStage:uint = uint(stage.stageWidth * 0.5);			       	  //Create a Lookup Table to precalculate the    //velocities of the particles.    //Determine the number of particles    //and their size, maximum speed and colors    private var _numberOfParticles:uint = 100;    private var _particleSize:uint = 2;    private var _speedLimit:int = 5;        //Create Vectors to store the particle velocities    private var _particle_Vx:Vector.<Number> = new Vector.<Number>;    private var _particle_Vy:Vector.<Number> = new Vector.<Number>;        //Create a Vector to store the colors    private var _colors:Vector.<uint> = new Vector.<uint>;    private var _randomColors:Vector.<uint> = new Vector.<uint>;      		//Create the lander and add its UI controller		private var _lander:LanderModel 		  = new LanderModel(30,30);		private var _landerUIController:LanderUIController 		  = new LanderUIController(_lander);		private var _lander_View:LanderView 		  = new LanderView(_lander);		private var _landerUIView:LanderUIView 		  = new LanderUIView(_lander, _landerUIController, stage);				//Create the lander's turret and add its UI controller		private var _turret:TurretModel 		  = new TurretModel(15, 3, 0x000000, -15, -160);		private var _turretUIController:TurretUIController 		  = new TurretUIController(_turret);		private var _turret_View:TurretView 		  = new TurretView(_turret);		private var _turretUIView:TurretUIView 		  = new TurretUIView(_turret, _turretUIController, stage);				//Array to store the bullet model and views		private var _bulletModels:Array = [];		private var _bulletViews:Array = [];				//Status box		private var _statusBox:StatusBox = new StatusBox;				//Variables required to display the cave bitmap		private var _caveBitmap:Bitmap;		private var _caveImage:DisplayObject;		private var _caveBitmapData:BitmapData;				//Array to store the explosions		private var _explosions:Array = [];				//The starting x position for the snapshots		private var _snapshot_X:int = 10;				//Create a performance profiler	  private var _performance:PerformanceProfiler 	    = new PerformanceProfiler();				//Embed the image of the cave    [Embed(source="../assets/images/caveTwo.png")]    private var CaveImage:Class;				public function UsingSounds():void		{ 		  //Start playing the music, and loop		  //it the maximum number of times		  _musicChannel = _music.play(0, int.MAX_VALUE);		  		  //Add colors to the _colors Vector	    _colors.push(0xFF6600, 0xFF9900, 0xFFCC00);	    	    //Create random velocities and colors for all the particles	    //and store them in the Vectors		  for (var i:uint = 0; i< _numberOfParticles; i++) 	    {		    //Give it a random velocity		    _particle_Vx[i]		      = (Math.random() * _speedLimit) - _speedLimit * 0.5;		    _particle_Vy[i]		      = (Math.random() * _speedLimit) - _speedLimit * 0.5;		      		    //Populate the _colors Vector with random colors  		     var randomColor:uint = uint(Math.random() * _colors.length);		     _randomColors.push(_colors[randomColor]);	    }	    		  //Add the lander to the stage			addChild(_lander_View);			_lander.setX = 75;			_lander.setY = 50;						//Add gravity			_lander.gravity_Vy = 0.1;						//Add the turret to the stage			addChild(_turret_View);						//Set the turret to the lander's position			_turret.setX = _lander.xPos;			_turret.setY = _lander.yPos - 13;						//Create a new instance of the CaveImage class			_caveImage = new CaveImage();						//Create a BitmapData object to store the image			_caveBitmapData 			  = new BitmapData			  (			     _caveImage.width, _caveImage.height, true, 0			  );						_caveBitmapData.draw(_caveImage);						//Create and add the cave bitmap image			_caveBitmap = new Bitmap(_caveBitmapData);			addChild(_caveBitmap);			_caveBitmap.x = 0;			_caveBitmap.y = 0;						//Add the status box			addChild(_statusBox);						addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}		private function enterFrameHandler(event:Event):void		{ 				//Update the lander and position the turret			_lander.update();			_turret.setX = _lander.xPos + _lander.width / 2;			_turret.setY = _lander.yPos + 2;			StageBoundaries.wrapBitmap(_lander, stage); 						bitmapCollision(_lander, _lander_View, _caveBitmap);						//Fire bullets			if(_turret.fireBullet == true)			{			  //Create the bulllet model and push it into 			  //the _bulletModels array        var bulletModel:CircleModel = new CircleModel(2);        _bulletModels.push(bulletModel);                    //Position the bullet model at the end of the turret         //and give it an initial velocity        bulletModel.setX           = _turret.xPos - _turret.width * Math.cos(_turret.angle);        bulletModel.setY           = _turret.yPos - _turret.width * Math.sin(_turret.angle);                  bulletModel.vx = Math.cos(_turret.angle) * -7;        bulletModel.vy = Math.sin(_turret.angle) * -7;        bulletModel.friction = 1;                  //Add the bullet views and push it into the _bulletViews array         var bulletView:CircleView = new CircleView(bulletModel);        addChild(bulletView);        _bulletViews.push(bulletView);                //Pan the sound of the bullet to match the 			  //its position on the stage			  if(_bulletModels[i].xPos < _halfStage)		    {		      _bulletPan 		        = (_bulletModels[i].xPos - _halfStage) / _halfStage;		    }		    else		    {		      _bulletPan 		        = (_bulletModels[i].xPos / _halfStage) - 1;		    }		    //Create the SoundTransform object based on the			  //new _explosionPan value			  var bulletTransform:SoundTransform 			    = new SoundTransform(_volume, _bulletPan);			            //Play the laser gun sound        _laserGunChannel = _laserGun.play(0, 1, bulletTransform);                  //Reset the turret so that it can fire again  			  _turret.fireBullet = false;			}						//Update the bullet models			for(var i:int = 0; i < _bulletModels.length; i++)      {        //Update them        _bulletModels[i].update();                //Check for a collision between the cave bitmap and the			  //bullets x and y position			  if(_caveBitmapData.hitTest			      (			        new Point(_caveBitmap.x, _caveBitmap.y), 			        255, 			        new Point(_bulletModels[i].xPos, _bulletModels[i].yPos)			        )			      )                                    			  { 			    //Add the circle			    var radius:int = 40;			    var circle:Shape = makeCircle(radius);			    			    //Take a snapshot of the area being hit			    			    //Create a blank BitmapData object to store the snapshot			    //It should be the same size as the circle			    var snapshotBitmapData:BitmapData 			      = new BitmapData(80, 80, true, 0);			    			    //Create a rectangle object that's also 			    //the same size as the circle. 			    //This is the viewfinder that finds 			    //the right spot on the bitmap to copy.					var rectangle:Rectangle = new Rectangle					  (					    _bulletModels[i].xPos - 40, 					    _bulletModels[i].yPos - 40, 					    80, 80				    );										//A point object, which is needed to define 					//the upper left corner of the bitmap					//Leave this at 0,0 unless you need to offset it.          var point:Point = new Point(0, 0);                    //Copy the pixels from the _caveBitmapData           //into the new snapshotBitmapData          //The rectangle and point objects specify which part to copy          snapshotBitmapData.copyPixels            (_caveBitmapData, rectangle, point);      			    //Add the explosion			    					var explosion:ColorExplosion 					  = new ColorExplosion					  (					    _numberOfParticles, 					    _particleSize, 					    _particle_Vx, 					    _particle_Vy,					    _randomColors					  );					 					explosion.x = 					  _bulletModels[i].xPos - explosion.width * 0.5;					explosion.y = 					  _bulletModels[i].yPos - explosion.height * 0.5;					  					addChild(explosion);					_explosions.push(explosion);					explosion.addEventListener			      ("explosionFinished", removeExplosion);			    			    //Pan the sound of the explosion to match the 			    //its position on the stage			    if(_bulletModels[i].xPos < _halfStage)			    {			      _explosionPan 			        = (_bulletModels[i].xPos - _halfStage) / _halfStage;			    }			    else			    {			      _explosionPan 			        = (_bulletModels[i].xPos / _halfStage) - 1;			    }			    			    //Create the SoundTransform object based on the			    //new _explosionPan value			    var explosionTransform:SoundTransform 			      = new SoundTransform(_volume, _explosionPan);			      			    //Play the explosion sound			    _explosionChannel 			      = _explosion.play(0, 1, explosionTransform);  								    //Create a Matrix object. 			    //It's used to position the circle shape			    //in the right place in the cave bitmap			    var matrix:Matrix = new Matrix();			    matrix.translate			      (_bulletModels[i].xPos, _bulletModels[i].yPos);			      			    //Redraw the cave bitmap using the 			    //circle shape and the matrix			    _caveBitmapData.draw(circle, matrix, null, BlendMode.ERASE);					  			    //Remove the bullet			    _bulletModels.splice(i, 1);					removeChild(_bulletViews[i]);					_bulletViews.splice(i, 1);					i--;										//Break the for loop					break;		    }      }           //Remove the bullets if they cross the stage boundaries			for(var k:int = 0; k < _bulletModels.length; k++)      {        if ((_bulletModels[k].yPos              + _bulletModels[k].height / 2 < 0)				|| (_bulletModels[k].yPos 				    - _bulletModels[k].height / 2 > stage.stageHeight)				|| (_bulletModels[k].xPos 				    + _bulletModels[k].width / 2 < 0)				|| (_bulletModels[k].xPos 				    - _bulletModels[k].width / 2 > stage.stageWidth))				{					_bulletModels.splice(k, 1);					removeChild(_bulletViews[k]);					_bulletViews.splice(k, 1);					k--;				}      }      //Update status box			_statusBox.text = "USING SOUNDS:"; 			_statusBox.text += "\n" + "EXPLOSION PAN: " + _explosionPan;  			_statusBox.text += "\n" + "BULLET PAN: " + _bulletPan; 		}				//Remove the explosion if the "explosionFinished"    //event is triggered by the explosion instance    public function removeExplosion(event:Event):void    {      for(var i:int = 0; i < _explosions.length; i++)      {        if(event.target == _explosions[i])        {          removeChild(_explosions[i]);          _explosions.splice(i, 1);          i--;         }      }    }    		private function bitmapCollision		  (		    model:AVerletModel, 		    view:AVerletView, 		    collisionBitmap:Bitmap		  ):void		{		  var bitmapData:BitmapData = new BitmapData		    (model.width, model.height, true, 0);		  bitmapData.draw(view); 						var objectBitmap:Object = createBitmap(model, view);						var loopCounter:int = 0;		  while (loopCounter++ != 10) 		  {			  if(objectBitmap.bitmapData.hitTest			      (			        new Point(model.xPos, model.yPos), 			        255, 			        collisionBitmap,			        new Point(collisionBitmap.x, collisionBitmap.y),			        255			       )			    )			  {    			    //Switch off gravity			 	  model.gravity_Vy = 0;			 	 			    //Create "collision boxes" on all four 			    //sides of the object to			    //find out which side the collision is occuring on			    			    //Check for a collision on the bottom			    if(objectBitmap.bitmapData.hitTest			        (			          new Point(model.xPos, model.yPos + 10), 			          255, 			          collisionBitmap,			          new Point(collisionBitmap.x, collisionBitmap.y),			          255			        )			      )			    {			      //Move the object out of the collision			      model.setY = model.yPos - 1;			      model.vy = 0;			    }			    			    //Check for a collision on the top			    else if(objectBitmap.bitmapData.hitTest			        (			          new Point(model.xPos, model.yPos - 10), 			          255, 			          collisionBitmap,			          new Point(collisionBitmap.x, collisionBitmap.y),			          255			        )			      )			    {			      //Move the object out of the collision			      model.setY = model.yPos + 1;			      model.vy = 0;			    } 			    			    //Check for a collision on the right			    if(objectBitmap.bitmapData.hitTest			        (			          new Point(model.xPos + 10, model.yPos), 			          255, 			          collisionBitmap,			          new Point(collisionBitmap.x, collisionBitmap.y),			          255			        )			      )			    {			      //Move the object out of the collision			      model.setX = model.xPos - 1;			      model.vx = 0;			    }			    			    //Check for a collision on the left 			    else if(objectBitmap.bitmapData.hitTest			        (			          new Point(model.xPos - 10, model.yPos), 			          255, 			          collisionBitmap,			          new Point(collisionBitmap.x, collisionBitmap.y),			          255			        )			      )			    {			      //Collision on left			      model.setX = model.xPos + 1;			      model.vx = 0;			    }			  }   			  else 			  {			    break;			  }		  }		  		  //Switch gravity back on if there is no ground below the object		  if(!objectBitmap.bitmapData.hitTest		      (		        new Point(model.xPos, model.yPos + 3), 			      255, 			      collisionBitmap,			      new Point(collisionBitmap.x, collisionBitmap.y),			      255			    )			  )			{			  model.gravity_Vy = 0.1;		  }	  }	  	  private function makeCircle(radius:int = 30):Shape		{		  //Create the shape		  var shape:Shape = new Shape();		  shape.graphics.lineStyle(0);			shape.graphics.beginFill(0xFFFFFF);			shape.graphics.drawCircle(0, 0, radius);			shape.graphics.endFill();						return shape	  }	  		private function createBitmap		  (		     model:AVerletModel, 		     view:AVerletView, 		     alphaTransparency:Boolean = true		  ):Object		{		  //BitmapData(width, height, transparent?, fillColor(0 is alpha))			var bitmapData:BitmapData = new BitmapData			  (model.width, model.height, alphaTransparency, 0);			  			bitmapData.draw(view);			var bitmap:Bitmap = new Bitmap(bitmapData);						//Create the object to return to the caller			var bitmapObject:Object = new Object;			bitmapObject.bitmapData = bitmapData;			bitmapObject.bitmap = bitmap;						return bitmapObject;		}	}}